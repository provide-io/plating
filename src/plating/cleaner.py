#
# plating/cleaner.py
#
"""Clean functionality for removing generated documentation."""

import shutil
from pathlib import Path

from rich.console import Console

from plating.results import CleanResult

console = Console()

# Common patterns for generated documentation files
GENERATED_FILE_PATTERNS = [
    "*.md",  # Generated markdown files
    "**/resources/*.md",  # Resource documentation
    "**/data_sources/*.md",  # Data source documentation  
    "**/functions/*.md",  # Function documentation
]

# Directories that are typically generated
GENERATED_DIRECTORIES = [
    "resources",
    "data_sources", 
    "data-sources",
    "functions",
    "guides",
]

# Files that indicate plating-generated content
PLATING_MARKERS = [
    ".plating-generated",  # Marker file we could create
    "# Generated by plating",  # Content marker in files
    "üçΩÔ∏è Generated with plating",  # Emoji marker
]


class PlatingCleaner:
    """Handles cleaning of generated plating documentation."""

    def __init__(self):
        """Initialize the cleaner."""
        pass

    def clean(self, output_dir: Path, dry_run: bool = False) -> CleanResult:
        """Remove all generated documentation files.

        Args:
            output_dir: Directory containing generated documentation
            dry_run: If True, only report what would be removed without actually removing

        Returns:
            CleanResult with details of what was cleaned
        """
        output_dir = Path(output_dir)
        
        if not output_dir.exists():
            return CleanResult(
                removed=[],
                dirs_removed=[],
                bytes_freed=0,
                dry_run=dry_run
            )

        # Find all files that appear to be generated
        files_to_remove = self._find_generated_files(output_dir)
        dirs_to_remove = self._find_generated_directories(output_dir)
        
        # Calculate total size before removal
        bytes_freed = self._calculate_total_size(files_to_remove + [d for d in dirs_to_remove if d.is_file()])
        
        removed_files = []
        removed_dirs = []

        if not dry_run:
            # Remove files first
            for file_path in files_to_remove:
                try:
                    if file_path.exists():
                        file_path.unlink()
                        removed_files.append(file_path)
                except OSError as e:
                    console.print(f"[yellow]Warning: Could not remove {file_path}: {e}[/yellow]")

            # Remove empty directories
            for dir_path in dirs_to_remove:
                try:
                    if dir_path.exists() and dir_path.is_dir():
                        # Only remove if empty or contains only our generated content
                        if self._is_safe_to_remove_directory(dir_path):
                            shutil.rmtree(dir_path)
                            removed_dirs.append(dir_path)
                except OSError as e:
                    console.print(f"[yellow]Warning: Could not remove directory {dir_path}: {e}[/yellow]")
        else:
            # Dry run - just record what would be removed
            removed_files = files_to_remove
            removed_dirs = dirs_to_remove

        return CleanResult(
            removed=removed_files,
            dirs_removed=removed_dirs,
            bytes_freed=bytes_freed,
            dry_run=dry_run
        )

    def _find_generated_files(self, output_dir: Path) -> list[Path]:
        """Find files that appear to be plating-generated.

        Args:
            output_dir: Directory to search

        Returns:
            List of file paths that appear to be generated
        """
        generated_files = []

        # Look for markdown files in typical plating output directories
        for pattern in GENERATED_FILE_PATTERNS:
            for file_path in output_dir.rglob(pattern):
                if file_path.is_file() and self._appears_generated(file_path):
                    generated_files.append(file_path)

        return generated_files

    def _find_generated_directories(self, output_dir: Path) -> list[Path]:
        """Find directories that appear to be plating-generated.

        Args:
            output_dir: Directory to search

        Returns:
            List of directory paths that appear to be generated
        """
        generated_dirs = []

        for dir_name in GENERATED_DIRECTORIES:
            dir_path = output_dir / dir_name
            if dir_path.exists() and dir_path.is_dir():
                # Check if directory contains only generated content
                if self._directory_appears_generated(dir_path):
                    generated_dirs.append(dir_path)

        return generated_dirs

    def _appears_generated(self, file_path: Path) -> bool:
        """Check if a file appears to be plating-generated.

        Args:
            file_path: Path to the file to check

        Returns:
            True if file appears to be generated by plating
        """
        try:
            # Read first few lines to look for plating markers
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read(1000)  # Read first 1KB

            # Check for plating-specific markers
            for marker in PLATING_MARKERS:
                if marker in content:
                    return True

            # Check for common terraform documentation patterns
            terraform_patterns = [
                "# Resource:",
                "# Data Source:",
                "# Function:",
                "## Example Usage",
                "## Argument Reference",
                "## Attribute Reference",
                "page_title:",
                "subcategory:",
                "description: |-",
            ]

            for pattern in terraform_patterns:
                if pattern in content:
                    return True

        except (OSError, UnicodeDecodeError):
            # If we can't read the file, be conservative and don't mark for deletion
            return False

        return False

    def _directory_appears_generated(self, dir_path: Path) -> bool:
        """Check if a directory appears to contain only generated content.

        Args:
            dir_path: Directory to check

        Returns:
            True if directory appears to contain only generated content
        """
        if not dir_path.exists() or not dir_path.is_dir():
            return False

        # Get all files in directory
        all_files = list(dir_path.rglob("*"))
        file_count = sum(1 for f in all_files if f.is_file())

        if file_count == 0:
            return True  # Empty directory

        # Count files that appear generated
        generated_count = sum(
            1 for f in all_files 
            if f.is_file() and self._appears_generated(f)
        )

        # If more than 80% of files appear generated, consider whole directory generated
        return (generated_count / file_count) > 0.8

    def _is_safe_to_remove_directory(self, dir_path: Path) -> bool:
        """Check if it's safe to remove a directory.

        Args:
            dir_path: Directory to check

        Returns:
            True if directory can be safely removed
        """
        try:
            # Don't remove if it contains any non-generated files
            for file_path in dir_path.rglob("*"):
                if file_path.is_file() and not self._appears_generated(file_path):
                    return False
            return True
        except OSError:
            return False

    def _calculate_total_size(self, files: list[Path]) -> int:
        """Calculate total size of files in bytes.

        Args:
            files: List of file paths

        Returns:
            Total size in bytes
        """
        total_size = 0
        for file_path in files:
            try:
                if file_path.exists():
                    if file_path.is_file():
                        total_size += file_path.stat().st_size
                    elif file_path.is_dir():
                        # Calculate directory size recursively
                        for sub_path in file_path.rglob("*"):
                            if sub_path.is_file():
                                total_size += sub_path.stat().st_size
            except OSError:
                continue  # Skip files we can't access
        return total_size


# üßπ‚ú®üóëÔ∏è