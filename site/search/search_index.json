{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Plating Documentation","text":"<p>Welcome to Plating - An async-first documentation generation system for Terraform/OpenTofu providers.</p>"},{"location":"#what-is-plating","title":"What is Plating?","text":"<p>Plating is a modern documentation generator that transforms your Terraform provider code into beautiful, Terraform Registry-compliant documentation. Built on foundation patterns for enterprise reliability, Plating makes documentation as delightful as a well-plated dish.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 Async-First Architecture: High-performance parallel processing</li> <li>\ud83d\udcdd Automatic Template Generation: Create documentation templates automatically</li> <li>\ud83c\udfa8 Beautiful Documentation: Generate Terraform Registry-compliant markdown</li> <li>\ud83d\udd0d Smart Discovery: Automatically find components via foundation.hub</li> <li>\u26a1 Foundation Integration: Built-in retry policies, metrics, and circuit breakers</li> <li>\ud83d\udcca Registry Pattern: Centralized component management and statistics</li> <li>\ud83d\udee1\ufe0f Enterprise Ready: Production-grade resilience and observability</li> </ul>"},{"location":"#part-of-the-provideio-ecosystem","title":"Part of the provide.io Ecosystem","text":"<p>This project is part of a larger ecosystem of tools for Python and Terraform development.</p> <p>View Ecosystem Overview \u2192</p> <p>Understand how provide-foundation, pyvider, flavorpack, and other projects work together.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<p>Beta Status</p> <p>plating is in beta. Core build orchestration features are functional, but the API may evolve.</p> <ul> <li>Current version: v0.0.1026</li> <li>Status: Beta (Development Status: 4)</li> <li>Installation: Install from source (not yet on PyPI)</li> </ul> <p>Installation:</p> <pre><code>$ git clone https://github.com/provide-io/plating.git\n$ cd plating\n$ uv sync\n// Installing dependencies...\nSuccessfully installed plating\n\n$ plating --help\nPlating - Modern async documentation generator\n</code></pre> <p>Coming soon to PyPI: <code>uv add plating</code></p>"},{"location":"#adorn-components-with-templates","title":"Adorn Components with Templates","text":"<p>Create <code>.plating</code> bundles for your undocumented components:</p> <pre><code>$ plating adorn --component-type resource\n// Discovering components...\n\ud83c\udfa8 Adorning 5 component types...\n\ud83d\udce6 Processing 10 resource(s)...\n\u2705 Generated 8 templates\n\ud83d\udce6 Processed 10 components\n</code></pre>"},{"location":"#generate-documentation","title":"Generate Documentation","text":"<p>Render your documentation from templates:</p> <pre><code>$ plating plate --output-dir docs/\n// Discovering plating bundles...\n\ud83c\udf7d\ufe0f Plating documentation...\n\u2705 Generated 10 files in 0.52s\n\ud83d\udce6 Processed 10 bundles\n\ud83d\udcc4 Generated files:\n  \u2022 docs/resources/example_resource.md\n  \u2022 docs/data-sources/example_data.md\n  \u2022 docs/functions/example_function.md\n  ... and 7 more\n</code></pre>"},{"location":"#validate-documentation","title":"Validate Documentation","text":"<p>Validate your generated documentation:</p> <pre><code>$ plating validate --output-dir docs/\n// Validating documentation in docs/...\n\ud83d\udcca Validation results:\n  \u2022 Total files: 10\n  \u2022 Passed: 10\n  \u2022 Failed: 0\n  \u2022 Duration: 0.23s\n\u2705 All validations passed\n</code></pre>"},{"location":"#python-api-usage","title":"Python API Usage","text":"<pre><code>import asyncio\nfrom plating import Plating, PlatingContext\nfrom plating.types import ComponentType\nfrom pathlib import Path\n\nasync def main():\n    # Initialize plating API with foundation context\n    context = PlatingContext(\n        provider_name=\"my_provider\",\n        log_level=\"INFO\",\n        no_color=False\n    )\n    api = Plating(context, package_name=\"pyvider.components\")\n\n    # Adorn components with templates\n    result = await api.adorn(component_types=[ComponentType.RESOURCE])\n    print(f\"Generated {result.templates_generated} templates\")\n\n    # Plate documentation (validation runs automatically if validate_markdown=True)\n    result = await api.plate(output_dir=Path(\"docs\"), validate_markdown=True)\n    print(f\"Generated {result.files_generated} files\")\n\n    # Note: validate_markdown=True runs validation during generation\n    # No need to call validate() separately unless you want to run it standalone\n\n# Run the async main function\nasyncio.run(main())\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Quick Start - Get up and running in 5 minutes</li> <li>Authoring Bundles - Create custom documentation</li> <li>Examples - Complete working examples</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>API Reference - Complete Python API documentation</li> <li>CLI Reference - Command-line interface and options</li> <li>Registry Pattern - Component discovery and management</li> </ul>"},{"location":"#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Performance - Optimization and best practices</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"#api-documentation","title":"API Documentation","text":"<ul> <li>Auto-generated API - Auto-generated API documentation from source code</li> </ul>"},{"location":"#component-types-supported","title":"Component Types Supported","text":"<ul> <li>Resources: Terraform resources (e.g., <code>aws_s3_bucket</code>)</li> <li>Data Sources: Terraform data sources (e.g., <code>aws_ami</code>)</li> <li>Functions: Provider functions (e.g., <code>timestamp()</code>)</li> <li>Providers: Provider configuration documentation</li> </ul>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>Plating follows a clean, modular architecture:</p> <pre><code>Plating API (async-first)\n    \u251c\u2500\u2500 Registry (component discovery)\n    \u251c\u2500\u2500 Template Engine (Jinja2)\n    \u251c\u2500\u2500 Schema Processor (extraction)\n    \u2514\u2500\u2500 Foundation Integration\n        \u251c\u2500\u2500 Retry Policies\n        \u251c\u2500\u2500 Circuit Breakers\n        \u2514\u2500\u2500 Metrics &amp; Observability\n</code></pre>"},{"location":"api-reference/","title":"Macro Rendering Error","text":"<p>File: <code>api-reference.md</code></p> <p>UndefinedError: 'schema' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 704, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 398, in top-level template code\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/utils.py\", line 92, in from_obj\n    if hasattr(obj, \"jinja_pass_arg\"):\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'schema' is undefined\n</code></pre>"},{"location":"authoring-bundles/","title":"Macro Rendering Error","text":"<p>File: <code>authoring-bundles.md</code></p> <p>UndefinedError: 'example' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 704, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 31, in top-level template code\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/utils.py\", line 92, in from_obj\n    if hasattr(obj, \"jinja_pass_arg\"):\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'example' is undefined\n</code></pre>"},{"location":"cli-reference/","title":"Macro Rendering Error","text":"<p>File: <code>cli-reference.md</code></p> <p>UndefinedError: 'env' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 704, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 401, in top-level template code\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 490, in getattr\n    return getattr(obj, attribute)\n           ^^^^^^^^^^^^^^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'env' is undefined\n</code></pre>"},{"location":"examples/","title":"Macro Rendering Error","text":"<p>File: <code>examples.md</code></p> <p>UndefinedError: 'format_date' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 704, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 252, in top-level template code\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/utils.py\", line 92, in from_obj\n    if hasattr(obj, \"jinja_pass_arg\"):\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'format_date' is undefined\n</code></pre>"},{"location":"performance/","title":"Macro Rendering Error","text":"<p>File: <code>performance.md</code></p> <p>UndefinedError: 'schema' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 704, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 238, in top-level template code\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/utils.py\", line 92, in from_obj\n    if hasattr(obj, \"jinja_pass_arg\"):\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'schema' is undefined\n</code></pre>"},{"location":"quick-start/","title":"Macro Rendering Error","text":"<p>File: <code>quick-start.md</code></p> <p>UndefinedError: 'example' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 704, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 113, in top-level template code\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/utils.py\", line 92, in from_obj\n    if hasattr(obj, \"jinja_pass_arg\"):\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'example' is undefined\n</code></pre>"},{"location":"registry-pattern/","title":"Registry Pattern","text":"<p>Plating uses a registry-based architecture for component discovery and management. This document explains how the registry works and how to interact with it.</p>"},{"location":"registry-pattern/#overview","title":"Overview","text":"<p>The PlatingRegistry is a centralized catalog of all components and their documentation bundles. It integrates with foundation's component discovery system to automatically find and register components.</p>"},{"location":"registry-pattern/#architecture","title":"Architecture","text":"<pre><code>PlatingRegistry\n\u251c\u2500\u2500 Component Discovery (via foundation.hub)\n\u251c\u2500\u2500 Bundle Registration (.plating directories)\n\u251c\u2500\u2500 Component Metadata (type, path, schema)\n\u2514\u2500\u2500 Statistics &amp; Queries\n</code></pre>"},{"location":"registry-pattern/#how-it-works","title":"How It Works","text":""},{"location":"registry-pattern/#1-automatic-discovery","title":"1. Automatic Discovery","text":"<p>When you create a Plating instance, it automatically discovers components:</p> <pre><code>from plating import Plating, PlatingContext\n\ncontext = PlatingContext(provider_name=\"my_provider\")\napi = Plating(context, package_name=\"pyvider.components\")\n\n# Registry is automatically populated with discovered components\n</code></pre>"},{"location":"registry-pattern/#2-component-registration","title":"2. Component Registration","text":"<p>Components are registered by type and name:</p> <pre><code># Internal registration happens automatically\nregistry.register(\n    name=\"my_resource\",\n    dimension=\"resource\",  # or \"data_source\", \"function\", \"provider\"\n    value=bundle_entry\n)\n</code></pre>"},{"location":"registry-pattern/#3-component-queries","title":"3. Component Queries","text":"<p>The registry provides methods to query components:</p> <pre><code># Get all resources\nresources = api.registry.get_components(ComponentType.RESOURCE)\n\n# Get specific component\nresource = api.registry.get_component(\n    ComponentType.RESOURCE,\n    \"my_resource\"\n)\n\n# Get components with templates\ndocumented = api.registry.get_components_with_templates(\n    ComponentType.RESOURCE\n)\n</code></pre>"},{"location":"registry-pattern/#registry-statistics","title":"Registry Statistics","text":"<p>Get insights into your provider's documentation:</p> <pre><code># Via API (synchronous method)\nstats = api.get_registry_stats()\n\n# Stats include:\n# - Total components by type\n# - Documentation coverage\n# - Bundle statistics\n</code></pre> <p>CLI command:</p> <pre><code>plating stats --package-name pyvider.components\n</code></pre> <p>Example output: <pre><code>\ud83d\udcca Registry Statistics\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nProvider: my_provider\nPackage: pyvider.components\n\nComponents:\n  Resources:     15 (12 documented)\n  Data Sources:  8  (8 documented)\n  Functions:     5  (3 documented)\n\nCoverage: 80% (23/28)\n</code></pre></p>"},{"location":"registry-pattern/#component-types","title":"Component Types","text":"<p>The registry organizes components into dimensions:</p> Type Dimension Directory Description <code>ComponentType.RESOURCE</code> \"resource\" <code>resources/</code> Terraform resources <code>ComponentType.DATA_SOURCE</code> \"data_source\" <code>data-sources/</code> Data sources <code>ComponentType.FUNCTION</code> \"function\" <code>functions/</code> Provider functions <code>ComponentType.PROVIDER</code> \"provider\" <code>providers/</code> Provider config"},{"location":"registry-pattern/#bundle-discovery","title":"Bundle Discovery","text":"<p>The registry finds <code>.plating</code> bundles in installed packages:</p> <pre><code># Search pattern for bundles\npackage_name/\n\u251c\u2500\u2500 resources/\n\u2502   \u251c\u2500\u2500 my_resource.py\n\u2502   \u2514\u2500\u2500 my_resource.plating/    # Discovered\n\u251c\u2500\u2500 data_sources/\n\u2502   \u2514\u2500\u2500 my_data.plating/        # Discovered\n\u2514\u2500\u2500 functions/\n    \u2514\u2500\u2500 my_function.plating/     # Discovered\n</code></pre>"},{"location":"registry-pattern/#multi-component-bundles","title":"Multi-Component Bundles","text":"<p>A single <code>.plating</code> directory can contain multiple component bundles:</p> <pre><code>components.plating/\n\u251c\u2500\u2500 resource1/\n\u2502   \u251c\u2500\u2500 docs/\n\u2502   \u2514\u2500\u2500 examples/\n\u251c\u2500\u2500 resource2/\n\u2502   \u251c\u2500\u2500 docs/\n\u2502   \u2514\u2500\u2500 examples/\n\u2514\u2500\u2500 data_source1/\n    \u251c\u2500\u2500 docs/\n    \u2514\u2500\u2500 examples/\n</code></pre>"},{"location":"registry-pattern/#registry-entry-structure","title":"Registry Entry Structure","text":"<p>Each registry entry contains:</p> <pre><code>PlatingRegistryEntry:\n  name: str                # Component name\n  dimension: str           # Component type\n  bundle: PlatingBundle    # Bundle instance\n  metadata:\n    path: Path            # Bundle directory path\n    component_type: str   # Type identifier\n    has_template: bool    # Has main template\n    has_examples: bool    # Has example files\n</code></pre>"},{"location":"registry-pattern/#package-filtering","title":"Package Filtering","text":"<p>Control which packages are searched:</p> <pre><code># Search specific package only\napi = Plating(context, package_name=\"pyvider.aws\")\n\n# Search all installed packages (slower)\napi = Plating(context)  # package_name=None\n</code></pre>"},{"location":"registry-pattern/#registry-resilience","title":"Registry Resilience","text":"<p>The registry includes foundation resilience patterns:</p> <ul> <li>Retry Policy: Automatic retries for discovery failures</li> <li>Error Recovery: Continues discovery even if some packages fail</li> <li>Deduplication: Prevents duplicate component registration</li> <li>Caching: Component metadata cached per session</li> </ul>"},{"location":"registry-pattern/#programmatic-access","title":"Programmatic Access","text":"<pre><code>import asyncio\nfrom plating import Plating, PlatingContext\nfrom plating.types import ComponentType\n\nasync def explore_registry():\n    context = PlatingContext(provider_name=\"my_provider\")\n    api = Plating(context)\n\n    # Get all resources\n    resources = api.registry.get_components(ComponentType.RESOURCE)\n    print(f\"Found {len(resources)} resources\")\n\n    # Check specific component\n    resource = api.registry.get_component(\n        ComponentType.RESOURCE,\n        \"my_resource\"\n    )\n    if resource:\n        print(f\"Resource path: {resource.plating_dir}\")\n        print(f\"Has template: {resource.has_main_template()}\")\n        print(f\"Has examples: {resource.has_examples()}\")\n\n    # Get registry statistics (synchronous method)\n    stats = api.get_registry_stats()\n    print(f\"Total components: {stats['total_components']}\")\n\n    # Print stats by component type\n    for comp_type in ['resource', 'data_source', 'function']:\n        if comp_type in stats:\n            print(f\"{comp_type}: {stats[comp_type]['with_templates']}/{stats[comp_type]['total']} documented\")\n\nasyncio.run(explore_registry())\n</code></pre>"},{"location":"registry-pattern/#custom-discovery","title":"Custom Discovery","text":"<p>For non-standard package structures, you can extend discovery:</p> <pre><code>from plating.discovery import PlatingDiscovery\n\nclass CustomDiscovery(PlatingDiscovery):\n    def discover_bundles(self):\n        bundles = super().discover_bundles()\n        # Add custom discovery logic\n        return bundles\n</code></pre>"},{"location":"registry-pattern/#best-practices","title":"Best Practices","text":"<ol> <li>Package Organization: Follow standard structure for automatic discovery</li> <li>Naming Conventions: Use consistent naming for components and bundles</li> <li>Package Filtering: Specify package_name for faster discovery</li> <li>Cache Registry: Reuse Plating instance to avoid re-discovery</li> </ol>"},{"location":"registry-pattern/#troubleshooting","title":"Troubleshooting","text":""},{"location":"registry-pattern/#no-components-found","title":"No Components Found","text":"<pre><code># Enable debug logging\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Check discovery\ncontext = PlatingContext(provider_name=\"my_provider\", log_level=\"DEBUG\")\napi = Plating(context)\n</code></pre>"},{"location":"registry-pattern/#duplicate-components","title":"Duplicate Components","text":"<p>The registry automatically deduplicates components during global discovery. If you see duplicates, check for multiple installations of the same package.</p>"},{"location":"registry-pattern/#performance-issues","title":"Performance Issues","text":"<p>For large environments with many packages:</p> <pre><code># Always specify package name\napi = Plating(context, package_name=\"specific.package\")\n\n# Avoid global discovery\n# api = Plating(context)  # Searches all packages\n</code></pre>"},{"location":"troubleshooting/","title":"Macro Syntax Error","text":"<p>File: <code>troubleshooting.md</code></p> <p>Line 66 in Markdown file: unexpected char '`' at 1486 <pre><code>   - Check for unmatched `{{` or `}}`\n</code></pre></p>"},{"location":"api/","title":"Plating API Reference","text":"<p>This page contains the complete API reference for the Plating package, automatically generated from source code docstrings.</p>"},{"location":"api/#quick-links","title":"Quick Links","text":"<p>For practical guides and usage examples, see:</p> <ul> <li>Getting Started - Installation and quick start guide</li> <li>API Reference - Comprehensive API documentation with examples</li> <li>Authoring Guide - Creating and maintaining plating bundles</li> <li>CLAUDE.md - Development setup and architecture overview</li> </ul>"},{"location":"api/#api-documentation","title":"API Documentation","text":"<p>Auto-generated API documentation for <code>plating</code>:</p> <p>Modern async documentation generation with full foundation integration.</p> <p>A clean, type-safe API for generating high-quality Terraform/OpenTofu provider documentation with foundation patterns.</p> <p>Key Features: - Type-safe async-first API - Full foundation integration (retry, metrics, circuit breakers) - Registry-based component discovery - Integrated markdown validation with configurable rules - Context-aware template rendering with Jinja2 - Support for resources, data sources, functions, and provider docs</p> Example Usage <pre><code>import asyncio\nfrom pathlib import Path\nfrom plating import Plating, ComponentType, PlatingContext\nfrom provide.foundation import pout\n\nasync def main():\n    # Initialize with foundation context\n    context = PlatingContext(\n        provider_name=\"my_provider\",\n        log_level=\"INFO\",\n        no_color=False\n    )\n\n    api = Plating(context)\n\n    # Create missing templates\n    adorn_result = await api.adorn(component_types=[ComponentType.RESOURCE])\n    pout(f\"\u2705 Created {adorn_result.templates_generated} templates\")\n\n    # Generate docs with validation\n    plate_result = await api.plate(\n        Path(\"docs\"),\n        component_types=[ComponentType.RESOURCE],\n        validate_markdown=True,\n        force=True\n    )\n\n    if plate_result.success:\n        pout(f\"\u2705 Generated {len(plate_result.output_files)} files\")\n\n    # Validate existing documentation\n    validation_result = await api.validate()\n    pout(f\"\ud83d\udcca Validation: {validation_result.passed}/{validation_result.total} passed\")\n\n# Run the async main\nasyncio.run(main())\n</code></pre> CLI Usage <pre><code># Create missing templates\nplating adorn --component-type resource --provider-name my_provider\n\n# Generate documentation\nplating plate --output-dir docs --validate\n\n# Validate existing docs\nplating validate --output-dir docs\n\n# Show registry info\nplating info --provider-name my_provider\n</code></pre>"},{"location":"api/#plating-attributes","title":"Attributes","text":""},{"location":"api/#plating.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = get_version('plating', caller_file=__file__)\n</code></pre>"},{"location":"api/#plating.plating_metrics","title":"plating_metrics  <code>module-attribute</code>","text":"<pre><code>plating_metrics = PlatingMetrics()\n</code></pre>"},{"location":"api/#plating.template_engine","title":"template_engine  <code>module-attribute</code>","text":"<pre><code>template_engine = AsyncTemplateEngine()\n</code></pre>"},{"location":"api/#plating.PlatingContext","title":"PlatingContext  <code>module-attribute</code>","text":"<pre><code>PlatingContext = PlatingCLIContext\n</code></pre>"},{"location":"api/#plating.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"AdornResult\",\n    \"ArgumentInfo\",\n    \"AsyncTemplateEngine\",\n    \"ComponentType\",\n    \"DocumentationAdorner\",\n    \"DocumentationPlater\",\n    \"FunctionPlatingBundle\",\n    \"ModularPlatingBundle\",\n    \"ModularPlatingDiscovery\",\n    \"PlateResult\",\n    \"Plating\",\n    \"PlatingContext\",\n    \"PlatingRegistry\",\n    \"SchemaInfo\",\n    \"TemplateMetadataExtractor\",\n    \"ValidationResult\",\n    \"__version__\",\n    \"get_plating_registry\",\n    \"plating\",\n    \"plating_metrics\",\n    \"reset_plating_registry\",\n    \"template_engine\",\n    \"with_circuit_breaker\",\n    \"with_metrics\",\n    \"with_retry\",\n    \"with_timing\",\n]\n</code></pre>"},{"location":"api/#plating-classes","title":"Classes","text":""},{"location":"api/#plating.FunctionPlatingBundle","title":"FunctionPlatingBundle","text":"<p>               Bases: <code>PlatingBundle</code></p> <p>Specialized PlatingBundle for individual function templates.</p>"},{"location":"api/#plating.FunctionPlatingBundle-attributes","title":"Attributes","text":""},{"location":"api/#plating.FunctionPlatingBundle.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.plating_dir","title":"plating_dir  <code>instance-attribute</code>","text":"<pre><code>plating_dir: Path\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.component_type","title":"component_type  <code>instance-attribute</code>","text":"<pre><code>component_type: str\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.docs_dir","title":"docs_dir  <code>property</code>","text":"<pre><code>docs_dir: Path\n</code></pre> <p>Directory containing documentation templates.</p>"},{"location":"api/#plating.FunctionPlatingBundle.examples_dir","title":"examples_dir  <code>property</code>","text":"<pre><code>examples_dir: Path\n</code></pre> <p>Directory containing example files.</p>"},{"location":"api/#plating.FunctionPlatingBundle.fixtures_dir","title":"fixtures_dir  <code>property</code>","text":"<pre><code>fixtures_dir: Path\n</code></pre> <p>Directory containing fixture files.</p>"},{"location":"api/#plating.FunctionPlatingBundle.template_file","title":"template_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_file: Path = field()\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle-functions","title":"Functions","text":""},{"location":"api/#plating.FunctionPlatingBundle.has_main_template","title":"has_main_template","text":"<pre><code>has_main_template() -&gt; bool\n</code></pre> <p>Check if bundle has a main template file.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def has_main_template(self) -&gt; bool:\n    \"\"\"Check if bundle has a main template file.\"\"\"\n    template_file = self.docs_dir / f\"{self.name}.tmpl.md\"\n    pyvider_template = self.docs_dir / f\"pyvider_{self.name}.tmpl.md\"\n    main_template = self.docs_dir / \"main.md.j2\"\n\n    return any(template.exists() for template in [template_file, pyvider_template, main_template])\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.has_examples","title":"has_examples","text":"<pre><code>has_examples() -&gt; bool\n</code></pre> <p>Check if bundle has example files (flat .tf or grouped).</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def has_examples(self) -&gt; bool:\n    \"\"\"Check if bundle has example files (flat .tf or grouped).\"\"\"\n    if not self.examples_dir.exists():\n        return False\n\n    # Check for flat .tf files\n    if any(self.examples_dir.glob(\"*.tf\")):\n        return True\n\n    # Check for grouped examples (subdirectories with main.tf)\n    return any(subdir.is_dir() and (subdir / \"main.tf\").exists() for subdir in self.examples_dir.iterdir())\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.load_examples","title":"load_examples","text":"<pre><code>load_examples() -&gt; dict[str, str]\n</code></pre> <p>Load all example files - both flat .tf and grouped subdirs.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping example name to content:</p> <code>dict[str, str]</code> <ul> <li>Flat .tf files: key is filename stem (e.g., \"basic.tf\" -&gt; \"basic\")</li> </ul> <code>dict[str, str]</code> <ul> <li>Grouped examples: key is subdirectory name (e.g., \"full_stack/main.tf\" -&gt; \"full_stack\")</li> </ul> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_examples(self) -&gt; dict[str, str]:\n    \"\"\"Load all example files - both flat .tf and grouped subdirs.\n\n    Returns:\n        Dictionary mapping example name to content:\n        - Flat .tf files: key is filename stem (e.g., \"basic.tf\" -&gt; \"basic\")\n        - Grouped examples: key is subdirectory name (e.g., \"full_stack/main.tf\" -&gt; \"full_stack\")\n    \"\"\"\n    examples: dict[str, str] = {}\n    if not self.examples_dir.exists():\n        return examples\n\n    # Load flat .tf files (backward compatible)\n    for example_file in self.examples_dir.glob(\"*.tf\"):\n        try:\n            examples[example_file.stem] = example_file.read_text(encoding=\"utf-8\")\n        except Exception:\n            continue\n\n    # Load grouped examples (subdirectories with main.tf)\n    for subdir in self.examples_dir.iterdir():\n        if subdir.is_dir():\n            main_tf = subdir / \"main.tf\"\n            if main_tf.exists():\n                try:\n                    examples[subdir.name] = main_tf.read_text(encoding=\"utf-8\")\n                except Exception:\n                    continue\n\n    return examples\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.load_partials","title":"load_partials","text":"<pre><code>load_partials() -&gt; dict[str, str]\n</code></pre> <p>Load all partial files from docs directory.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_partials(self) -&gt; dict[str, str]:\n    \"\"\"Load all partial files from docs directory.\"\"\"\n    partials: dict[str, str] = {}\n    if not self.docs_dir.exists():\n        return partials\n\n    for partial_file in self.docs_dir.glob(\"_*\"):\n        if partial_file.is_file():\n            try:\n                partials[partial_file.name] = partial_file.read_text(encoding=\"utf-8\")\n            except Exception:\n                continue\n    return partials\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.load_fixtures","title":"load_fixtures","text":"<pre><code>load_fixtures() -&gt; dict[str, str]\n</code></pre> <p>Load all fixture files from fixtures directory.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_fixtures(self) -&gt; dict[str, str]:\n    \"\"\"Load all fixture files from fixtures directory.\"\"\"\n    fixtures: dict[str, str] = {}\n    if not self.fixtures_dir.exists():\n        return fixtures\n\n    for fixture_file in self.fixtures_dir.rglob(\"*\"):\n        if fixture_file.is_file():\n            try:\n                rel_path = fixture_file.relative_to(self.fixtures_dir)\n                fixtures[str(rel_path)] = fixture_file.read_text(encoding=\"utf-8\")\n            except Exception:\n                continue\n    return fixtures\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.get_example_groups","title":"get_example_groups","text":"<pre><code>get_example_groups() -&gt; list[str]\n</code></pre> <p>Get names of example groups (subdirectories with main.tf).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of group names (subdirectory names)</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def get_example_groups(self) -&gt; list[str]:\n    \"\"\"Get names of example groups (subdirectories with main.tf).\n\n    Returns:\n        List of group names (subdirectory names)\n    \"\"\"\n    if not self.examples_dir.exists():\n        return []\n\n    group_names = []\n    for subdir in self.examples_dir.iterdir():\n        if subdir.is_dir() and (subdir / \"main.tf\").exists():\n            group_names.append(subdir.name)\n\n    return group_names\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.load_group_fixtures","title":"load_group_fixtures","text":"<pre><code>load_group_fixtures(group_name: str) -&gt; dict[str, Path]\n</code></pre> <p>Load fixture files from a specific example group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name of the example group</p> required <p>Returns:</p> Type Description <code>dict[str, Path]</code> <p>Dictionary mapping relative path to source Path object</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_group_fixtures(self, group_name: str) -&gt; dict[str, Path]:\n    \"\"\"Load fixture files from a specific example group.\n\n    Args:\n        group_name: Name of the example group\n\n    Returns:\n        Dictionary mapping relative path to source Path object\n    \"\"\"\n    group_fixtures_dir = self.examples_dir / group_name / \"fixtures\"\n    if not group_fixtures_dir.exists():\n        return {}\n\n    fixtures = {}\n    for file_path in group_fixtures_dir.rglob(\"*\"):\n        if file_path.is_file():\n            rel_path = file_path.relative_to(group_fixtures_dir)\n            fixtures[str(rel_path)] = file_path\n\n    return fixtures\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.load_main_template","title":"load_main_template","text":"<pre><code>load_main_template() -&gt; str | None\n</code></pre> <p>Load the specific template file for this function.</p> Source code in <code>src/plating/bundles/function.py</code> <pre><code>def load_main_template(self) -&gt; str | None:\n    \"\"\"Load the specific template file for this function.\"\"\"\n    try:\n        return self.template_file.read_text(encoding=\"utf-8\")\n    except Exception:\n        return None\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle","title":"ModularPlatingBundle","text":"<p>Represents a single .plating bundle with its assets.</p>"},{"location":"api/#plating.ModularPlatingBundle-attributes","title":"Attributes","text":""},{"location":"api/#plating.ModularPlatingBundle.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.plating_dir","title":"plating_dir  <code>instance-attribute</code>","text":"<pre><code>plating_dir: Path\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.component_type","title":"component_type  <code>instance-attribute</code>","text":"<pre><code>component_type: str\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.docs_dir","title":"docs_dir  <code>property</code>","text":"<pre><code>docs_dir: Path\n</code></pre> <p>Directory containing documentation templates.</p>"},{"location":"api/#plating.ModularPlatingBundle.examples_dir","title":"examples_dir  <code>property</code>","text":"<pre><code>examples_dir: Path\n</code></pre> <p>Directory containing example files.</p>"},{"location":"api/#plating.ModularPlatingBundle.fixtures_dir","title":"fixtures_dir  <code>property</code>","text":"<pre><code>fixtures_dir: Path\n</code></pre> <p>Directory containing fixture files.</p>"},{"location":"api/#plating.ModularPlatingBundle-functions","title":"Functions","text":""},{"location":"api/#plating.ModularPlatingBundle.has_main_template","title":"has_main_template","text":"<pre><code>has_main_template() -&gt; bool\n</code></pre> <p>Check if bundle has a main template file.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def has_main_template(self) -&gt; bool:\n    \"\"\"Check if bundle has a main template file.\"\"\"\n    template_file = self.docs_dir / f\"{self.name}.tmpl.md\"\n    pyvider_template = self.docs_dir / f\"pyvider_{self.name}.tmpl.md\"\n    main_template = self.docs_dir / \"main.md.j2\"\n\n    return any(template.exists() for template in [template_file, pyvider_template, main_template])\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.has_examples","title":"has_examples","text":"<pre><code>has_examples() -&gt; bool\n</code></pre> <p>Check if bundle has example files (flat .tf or grouped).</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def has_examples(self) -&gt; bool:\n    \"\"\"Check if bundle has example files (flat .tf or grouped).\"\"\"\n    if not self.examples_dir.exists():\n        return False\n\n    # Check for flat .tf files\n    if any(self.examples_dir.glob(\"*.tf\")):\n        return True\n\n    # Check for grouped examples (subdirectories with main.tf)\n    return any(subdir.is_dir() and (subdir / \"main.tf\").exists() for subdir in self.examples_dir.iterdir())\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.load_main_template","title":"load_main_template","text":"<pre><code>load_main_template() -&gt; str | None\n</code></pre> <p>Load the main template file for this component.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_main_template(self) -&gt; str | None:\n    \"\"\"Load the main template file for this component.\"\"\"\n    template_file = self.docs_dir / f\"{self.name}.tmpl.md\"\n    pyvider_template = self.docs_dir / f\"pyvider_{self.name}.tmpl.md\"\n    main_template = self.docs_dir / \"main.md.j2\"\n\n    # First, try component-specific templates\n    for template_path in [template_file, pyvider_template]:\n        if template_path.exists():\n            try:\n                return template_path.read_text(encoding=\"utf-8\")\n            except Exception:\n                return None\n\n    # Only use main.md.j2 if it's the only component in this bundle directory\n    # Check if this bundle contains multiple components by looking for other .tmpl.md files\n    if main_template.exists():\n        component_templates = list(self.docs_dir.glob(\"*.tmpl.md\"))\n        if len(component_templates) &lt;= 1:  # Only this component or no specific templates\n            try:\n                return main_template.read_text(encoding=\"utf-8\")\n            except Exception:\n                return None\n\n    return None\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.load_examples","title":"load_examples","text":"<pre><code>load_examples() -&gt; dict[str, str]\n</code></pre> <p>Load all example files - both flat .tf and grouped subdirs.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping example name to content:</p> <code>dict[str, str]</code> <ul> <li>Flat .tf files: key is filename stem (e.g., \"basic.tf\" -&gt; \"basic\")</li> </ul> <code>dict[str, str]</code> <ul> <li>Grouped examples: key is subdirectory name (e.g., \"full_stack/main.tf\" -&gt; \"full_stack\")</li> </ul> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_examples(self) -&gt; dict[str, str]:\n    \"\"\"Load all example files - both flat .tf and grouped subdirs.\n\n    Returns:\n        Dictionary mapping example name to content:\n        - Flat .tf files: key is filename stem (e.g., \"basic.tf\" -&gt; \"basic\")\n        - Grouped examples: key is subdirectory name (e.g., \"full_stack/main.tf\" -&gt; \"full_stack\")\n    \"\"\"\n    examples: dict[str, str] = {}\n    if not self.examples_dir.exists():\n        return examples\n\n    # Load flat .tf files (backward compatible)\n    for example_file in self.examples_dir.glob(\"*.tf\"):\n        try:\n            examples[example_file.stem] = example_file.read_text(encoding=\"utf-8\")\n        except Exception:\n            continue\n\n    # Load grouped examples (subdirectories with main.tf)\n    for subdir in self.examples_dir.iterdir():\n        if subdir.is_dir():\n            main_tf = subdir / \"main.tf\"\n            if main_tf.exists():\n                try:\n                    examples[subdir.name] = main_tf.read_text(encoding=\"utf-8\")\n                except Exception:\n                    continue\n\n    return examples\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.load_partials","title":"load_partials","text":"<pre><code>load_partials() -&gt; dict[str, str]\n</code></pre> <p>Load all partial files from docs directory.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_partials(self) -&gt; dict[str, str]:\n    \"\"\"Load all partial files from docs directory.\"\"\"\n    partials: dict[str, str] = {}\n    if not self.docs_dir.exists():\n        return partials\n\n    for partial_file in self.docs_dir.glob(\"_*\"):\n        if partial_file.is_file():\n            try:\n                partials[partial_file.name] = partial_file.read_text(encoding=\"utf-8\")\n            except Exception:\n                continue\n    return partials\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.load_fixtures","title":"load_fixtures","text":"<pre><code>load_fixtures() -&gt; dict[str, str]\n</code></pre> <p>Load all fixture files from fixtures directory.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_fixtures(self) -&gt; dict[str, str]:\n    \"\"\"Load all fixture files from fixtures directory.\"\"\"\n    fixtures: dict[str, str] = {}\n    if not self.fixtures_dir.exists():\n        return fixtures\n\n    for fixture_file in self.fixtures_dir.rglob(\"*\"):\n        if fixture_file.is_file():\n            try:\n                rel_path = fixture_file.relative_to(self.fixtures_dir)\n                fixtures[str(rel_path)] = fixture_file.read_text(encoding=\"utf-8\")\n            except Exception:\n                continue\n    return fixtures\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.get_example_groups","title":"get_example_groups","text":"<pre><code>get_example_groups() -&gt; list[str]\n</code></pre> <p>Get names of example groups (subdirectories with main.tf).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of group names (subdirectory names)</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def get_example_groups(self) -&gt; list[str]:\n    \"\"\"Get names of example groups (subdirectories with main.tf).\n\n    Returns:\n        List of group names (subdirectory names)\n    \"\"\"\n    if not self.examples_dir.exists():\n        return []\n\n    group_names = []\n    for subdir in self.examples_dir.iterdir():\n        if subdir.is_dir() and (subdir / \"main.tf\").exists():\n            group_names.append(subdir.name)\n\n    return group_names\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.load_group_fixtures","title":"load_group_fixtures","text":"<pre><code>load_group_fixtures(group_name: str) -&gt; dict[str, Path]\n</code></pre> <p>Load fixture files from a specific example group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name of the example group</p> required <p>Returns:</p> Type Description <code>dict[str, Path]</code> <p>Dictionary mapping relative path to source Path object</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_group_fixtures(self, group_name: str) -&gt; dict[str, Path]:\n    \"\"\"Load fixture files from a specific example group.\n\n    Args:\n        group_name: Name of the example group\n\n    Returns:\n        Dictionary mapping relative path to source Path object\n    \"\"\"\n    group_fixtures_dir = self.examples_dir / group_name / \"fixtures\"\n    if not group_fixtures_dir.exists():\n        return {}\n\n    fixtures = {}\n    for file_path in group_fixtures_dir.rglob(\"*\"):\n        if file_path.is_file():\n            rel_path = file_path.relative_to(group_fixtures_dir)\n            fixtures[str(rel_path)] = file_path\n\n    return fixtures\n</code></pre>"},{"location":"api/#plating.ModularPlatingDiscovery","title":"ModularPlatingDiscovery","text":"<pre><code>ModularPlatingDiscovery(package_name: str | None = None)\n</code></pre> <p>Discovers .plating bundles from installed packages.</p> <p>Initialize discovery.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str | None</code> <p>Specific package to search, or None to search all packages</p> <code>None</code> Source code in <code>src/plating/discovery/finder.py</code> <pre><code>def __init__(self, package_name: str | None = None) -&gt; None:\n    \"\"\"Initialize discovery.\n\n    Args:\n        package_name: Specific package to search, or None to search all packages\n    \"\"\"\n    self.package_name = package_name\n</code></pre>"},{"location":"api/#plating.ModularPlatingDiscovery-attributes","title":"Attributes","text":""},{"location":"api/#plating.ModularPlatingDiscovery.package_name","title":"package_name  <code>instance-attribute</code>","text":"<pre><code>package_name = package_name\n</code></pre>"},{"location":"api/#plating.ModularPlatingDiscovery-functions","title":"Functions","text":""},{"location":"api/#plating.ModularPlatingDiscovery.discover_bundles","title":"discover_bundles","text":"<pre><code>discover_bundles(\n    component_type: str | None = None,\n) -&gt; list[PlatingBundle]\n</code></pre> <p>Discover all .plating bundles from installed package(s).</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <code>str | None</code> <p>Optional filter for specific component type</p> <code>None</code> <p>Returns:</p> Type Description <code>list[PlatingBundle]</code> <p>List of discovered PlatingBundle objects</p> Source code in <code>src/plating/discovery/finder.py</code> <pre><code>def discover_bundles(self, component_type: str | None = None) -&gt; list[PlatingBundle]:\n    \"\"\"Discover all .plating bundles from installed package(s).\n\n    Args:\n        component_type: Optional filter for specific component type\n\n    Returns:\n        List of discovered PlatingBundle objects\n    \"\"\"\n    if self.package_name:\n        # Single package discovery\n        return self._discover_from_package(self.package_name, component_type)\n    else:\n        # Global discovery from all installed packages\n        return self._discover_from_all_packages(component_type)\n</code></pre>"},{"location":"api/#plating.DocumentationAdorner","title":"DocumentationAdorner","text":"<pre><code>DocumentationAdorner()\n</code></pre> <p>Enhances documentation content with metadata and template variables.</p> Source code in <code>src/plating/generation/adorner.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.config = get_config()\n</code></pre>"},{"location":"api/#plating.DocumentationAdorner-attributes","title":"Attributes","text":""},{"location":"api/#plating.DocumentationAdorner.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = get_config()\n</code></pre>"},{"location":"api/#plating.DocumentationAdorner-functions","title":"Functions","text":""},{"location":"api/#plating.DocumentationAdorner.adorn_function_template","title":"adorn_function_template","text":"<pre><code>adorn_function_template(\n    template_content: str,\n    function_name: str,\n    metadata: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Create template context for function documentation.</p> <p>Parameters:</p> Name Type Description Default <code>template_content</code> <code>str</code> <p>Raw template content</p> required <code>function_name</code> <code>str</code> <p>Name of the function</p> required <code>metadata</code> <code>dict[str, Any]</code> <p>Function metadata from extractor</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing all template variables</p> Source code in <code>src/plating/generation/adorner.py</code> <pre><code>def adorn_function_template(\n    self, template_content: str, function_name: str, metadata: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Create template context for function documentation.\n\n    Args:\n        template_content: Raw template content\n        function_name: Name of the function\n        metadata: Function metadata from extractor\n\n    Returns:\n        Dictionary containing all template variables\n    \"\"\"\n\n    # Create example function that templates can call\n    def example(example_name: str) -&gt; str:\n        examples = metadata.get(\"examples\", {})\n        result = examples.get(example_name, self.config.example_placeholder)\n        return str(result)\n\n    return {\n        \"function_name\": function_name,\n        \"template_content\": template_content,\n        \"example\": example,\n        **metadata,\n    }\n</code></pre>"},{"location":"api/#plating.DocumentationAdorner.adorn_resource_template","title":"adorn_resource_template","text":"<pre><code>adorn_resource_template(\n    template_content: str,\n    resource_name: str,\n    metadata: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Create template context for resource documentation.</p> <p>Parameters:</p> Name Type Description Default <code>template_content</code> <code>str</code> <p>Raw template content</p> required <code>resource_name</code> <code>str</code> <p>Name of the resource</p> required <code>metadata</code> <code>dict[str, Any]</code> <p>Resource metadata</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing all template variables</p> Source code in <code>src/plating/generation/adorner.py</code> <pre><code>def adorn_resource_template(\n    self, template_content: str, resource_name: str, metadata: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Create template context for resource documentation.\n\n    Args:\n        template_content: Raw template content\n        resource_name: Name of the resource\n        metadata: Resource metadata\n\n    Returns:\n        Dictionary containing all template variables\n    \"\"\"\n\n    # Create example function that templates can call\n    def example(example_name: str) -&gt; str:\n        examples = metadata.get(\"examples\", {})\n        result = examples.get(example_name, self.config.example_placeholder)\n        return str(result)\n\n    # Create schema function that templates can call\n    def schema() -&gt; str:\n        schema_info = metadata.get(\"schema\", {})\n        if not schema_info:\n            return \"No schema information available.\"\n        # Convert schema to markdown format\n        return str(schema_info)\n\n    return {\n        \"resource_name\": resource_name,\n        \"template_content\": template_content,\n        \"example\": example,\n        \"schema\": schema,\n        **metadata,\n    }\n</code></pre>"},{"location":"api/#plating.DocumentationAdorner.enhance_template_context","title":"enhance_template_context","text":"<pre><code>enhance_template_context(\n    context: dict[str, Any], additional_data: dict[str, Any]\n) -&gt; dict[str, Any]\n</code></pre> <p>Enhance template context with additional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict[str, Any]</code> <p>Base template context</p> required <code>additional_data</code> <code>dict[str, Any]</code> <p>Additional data to merge</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Enhanced template context</p> Source code in <code>src/plating/generation/adorner.py</code> <pre><code>def enhance_template_context(\n    self, context: dict[str, Any], additional_data: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Enhance template context with additional metadata.\n\n    Args:\n        context: Base template context\n        additional_data: Additional data to merge\n\n    Returns:\n        Enhanced template context\n    \"\"\"\n    enhanced = context.copy()\n    enhanced.update(additional_data)\n    return enhanced\n</code></pre>"},{"location":"api/#plating.DocumentationPlater","title":"DocumentationPlater","text":"<pre><code>DocumentationPlater(package_name: str)\n</code></pre> <p>Orchestrates the complete documentation generation process using async rendering.</p> Source code in <code>src/plating/generation/plater.py</code> <pre><code>def __init__(self, package_name: str) -&gt; None:\n    self.package_name = package_name\n    self.discovery = PlatingDiscovery(package_name)\n    self.extractor = TemplateMetadataExtractor()\n    self.adorner = DocumentationAdorner()\n    self.renderer = AsyncTemplateEngine()\n</code></pre>"},{"location":"api/#plating.DocumentationPlater-attributes","title":"Attributes","text":""},{"location":"api/#plating.DocumentationPlater.package_name","title":"package_name  <code>instance-attribute</code>","text":"<pre><code>package_name = package_name\n</code></pre>"},{"location":"api/#plating.DocumentationPlater.discovery","title":"discovery  <code>instance-attribute</code>","text":"<pre><code>discovery = PlatingDiscovery(package_name)\n</code></pre>"},{"location":"api/#plating.DocumentationPlater.extractor","title":"extractor  <code>instance-attribute</code>","text":"<pre><code>extractor = TemplateMetadataExtractor()\n</code></pre>"},{"location":"api/#plating.DocumentationPlater.adorner","title":"adorner  <code>instance-attribute</code>","text":"<pre><code>adorner = DocumentationAdorner()\n</code></pre>"},{"location":"api/#plating.DocumentationPlater.renderer","title":"renderer  <code>instance-attribute</code>","text":"<pre><code>renderer = AsyncTemplateEngine()\n</code></pre>"},{"location":"api/#plating.DocumentationPlater-functions","title":"Functions","text":""},{"location":"api/#plating.DocumentationPlater.generate_documentation","title":"generate_documentation  <code>async</code>","text":"<pre><code>generate_documentation(\n    output_dir: Path, component_type: str | None = None\n) -&gt; list[tuple[Path, str]]\n</code></pre> <p>Generate documentation for all discovered components.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>Path</code> <p>Directory to write generated documentation</p> required <code>component_type</code> <code>str | None</code> <p>Optional filter for component type</p> <code>None</code> <p>Returns:</p> Type Description <code>list[tuple[Path, str]]</code> <p>List of (file_path, content) tuples for generated files</p> Source code in <code>src/plating/generation/plater.py</code> <pre><code>async def generate_documentation(\n    self, output_dir: Path, component_type: str | None = None\n) -&gt; list[tuple[Path, str]]:\n    \"\"\"Generate documentation for all discovered components.\n\n    Args:\n        output_dir: Directory to write generated documentation\n        component_type: Optional filter for component type\n\n    Returns:\n        List of (file_path, content) tuples for generated files\n    \"\"\"\n    bundles = self.discovery.discover_bundles(component_type)\n    generated_files: list[tuple[Path, str]] = []\n\n    for bundle in bundles:\n        if isinstance(bundle, FunctionPlatingBundle):\n            files = await self._generate_function_documentation(bundle, output_dir)\n            generated_files.extend(files)\n        else:\n            files = await self._generate_component_documentation(bundle, output_dir)\n            generated_files.extend(files)\n\n    return generated_files\n</code></pre>"},{"location":"api/#plating.Plating","title":"Plating","text":"<pre><code>Plating(\n    context: PlatingContext, package_name: str | None = None\n)\n</code></pre> <p>Modern async API for all plating operations with foundation integration.</p> <p>Initialize plating API with foundation context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PlatingContext</code> <p>PlatingContext with configuration (required)</p> required <code>package_name</code> <code>str | None</code> <p>Package to search for plating bundles, or None to search all packages</p> <code>None</code> Source code in <code>src/plating/plating.py</code> <pre><code>def __init__(self, context: PlatingContext, package_name: str | None = None) -&gt; None:\n    \"\"\"Initialize plating API with foundation context.\n\n    Args:\n        context: PlatingContext with configuration (required)\n        package_name: Package to search for plating bundles, or None to search all packages\n    \"\"\"\n    self.context = context\n    self.package_name = package_name\n\n    # Foundation patterns\n    self.registry = get_plating_registry(package_name)\n\n    # Schema processing\n    self._provider_schema: dict[str, Any] | None = None\n\n    # Resilience patterns for file I/O and network operations\n    self.retry_policy = RetryPolicy(\n        max_attempts=3,\n        backoff=BackoffStrategy.EXPONENTIAL,\n        base_delay=0.5,\n        max_delay=10.0,\n        retryable_errors=(IOError, OSError, TimeoutError, ConnectionError),\n    )\n</code></pre>"},{"location":"api/#plating.Plating-attributes","title":"Attributes","text":""},{"location":"api/#plating.Plating.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context = context\n</code></pre>"},{"location":"api/#plating.Plating.package_name","title":"package_name  <code>instance-attribute</code>","text":"<pre><code>package_name = package_name\n</code></pre>"},{"location":"api/#plating.Plating.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry = get_plating_registry(package_name)\n</code></pre>"},{"location":"api/#plating.Plating.retry_policy","title":"retry_policy  <code>instance-attribute</code>","text":"<pre><code>retry_policy = RetryPolicy(\n    max_attempts=3,\n    backoff=EXPONENTIAL,\n    base_delay=0.5,\n    max_delay=10.0,\n    retryable_errors=(\n        IOError,\n        OSError,\n        TimeoutError,\n        ConnectionError,\n    ),\n)\n</code></pre>"},{"location":"api/#plating.Plating-functions","title":"Functions","text":""},{"location":"api/#plating.Plating.adorn","title":"adorn  <code>async</code>","text":"<pre><code>adorn(\n    component_types: list[ComponentType] | None = None,\n) -&gt; AdornResult\n</code></pre> <p>Generate template structure for discovered components.</p> <p>Parameters:</p> Name Type Description Default <code>component_types</code> <code>list[ComponentType] | None</code> <p>Specific component types to adorn</p> <code>None</code> <p>Returns:</p> Type Description <code>AdornResult</code> <p>AdornResult with generation statistics</p> Source code in <code>src/plating/plating.py</code> <pre><code>@with_timing\n@with_retry()\n@with_metrics(\"adorn\")\nasync def adorn(\n    self,\n    component_types: list[ComponentType] | None = None,\n) -&gt; AdornResult:\n    \"\"\"Generate template structure for discovered components.\n\n    Args:\n        component_types: Specific component types to adorn\n\n    Returns:\n        AdornResult with generation statistics\n    \"\"\"\n    if not self.package_name:\n        pout(\n            \"\u26a0\ufe0f  Adorn requires a package name. Run with --package-name or in a project with pyproject.toml.\"\n        )\n        return AdornResult(errors=[\"--package-name is required for adorn.\"])\n\n    pout(f\"\ud83c\udfa8 Adorning components in package: {self.package_name}\")\n\n    try:\n        adorner = PlatingAdorner(self.package_name)\n        target_types = [ct.value for ct in component_types] if component_types else None\n        adorned_counts = await adorner.adorn_missing(target_types)\n\n        total_adorned = sum(adorned_counts.values())\n\n        return AdornResult(\n            templates_generated=total_adorned,\n            examples_created=total_adorned,  # Each adorn creates one template and one example\n            errors=[],\n        )\n\n    except Exception as e:\n        logger.error(\"Adorn operation failed\", error=str(e))\n        return AdornResult(errors=[f\"An unexpected error occurred: {e}\"])\n</code></pre>"},{"location":"api/#plating.Plating.plate","title":"plate  <code>async</code>","text":"<pre><code>plate(\n    output_dir: Path | None = None,\n    component_types: list[ComponentType] | None = None,\n    force: bool = False,\n    validate_markdown: bool = True,\n    project_root: Path | None = None,\n) -&gt; PlateResult\n</code></pre> <p>Generate documentation from plating bundles.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>Path | None</code> <p>Output directory for documentation</p> <code>None</code> <code>component_types</code> <code>list[ComponentType] | None</code> <p>Component types to generate</p> <code>None</code> <code>force</code> <code>bool</code> <p>Overwrite existing files</p> <code>False</code> <code>validate_markdown</code> <code>bool</code> <p>Enable markdown validation</p> <code>True</code> <code>project_root</code> <code>Path | None</code> <p>Project root directory (auto-detected if not provided)</p> <code>None</code> <p>Returns:</p> Type Description <code>PlateResult</code> <p>PlateResult with generation statistics</p> Source code in <code>src/plating/plating.py</code> <pre><code>@with_timing\n@with_retry()\n@with_metrics(\"plate\")\nasync def plate(\n    self,\n    output_dir: Path | None = None,\n    component_types: list[ComponentType] | None = None,\n    force: bool = False,\n    validate_markdown: bool = True,\n    project_root: Path | None = None,\n) -&gt; PlateResult:\n    \"\"\"Generate documentation from plating bundles.\n\n    Args:\n        output_dir: Output directory for documentation\n        component_types: Component types to generate\n        force: Overwrite existing files\n        validate_markdown: Enable markdown validation\n        project_root: Project root directory (auto-detected if not provided)\n\n    Returns:\n        PlateResult with generation statistics\n    \"\"\"\n    # Detect project root if not provided\n    if project_root is None:\n        project_root = find_project_root()\n\n    # Determine final output directory with improved logic\n    final_output_dir = get_output_directory(output_dir, project_root)\n\n    logger.info(f\"Using output directory: {final_output_dir}\")\n    if project_root:\n        logger.info(f\"Project root detected: {project_root}\")\n    else:\n        logger.warning(\"No project root detected, using current directory as base\")\n\n    # Validate and create output directory\n    try:\n        final_output_dir.mkdir(parents=True, exist_ok=True)\n    except (PermissionError, OSError) as e:\n        logger.error(\"Failed to create output directory\", path=final_output_dir, error=str(e))\n        raise FileSystemError(\n            path=final_output_dir, operation=\"create directory\", reason=str(e), caused_by=e\n        ) from e\n\n    # Ensure we can write to the directory\n    if not os.access(final_output_dir, os.W_OK):\n        logger.error(\"Output directory is not writable\", path=final_output_dir)\n        raise FileSystemError(\n            path=final_output_dir,\n            operation=\"write\",\n            reason=\"Directory is not writable (check permissions)\",\n        )\n\n    if not component_types:\n        component_types = [ComponentType.RESOURCE, ComponentType.DATA_SOURCE, ComponentType.FUNCTION]\n\n    start_time = time.monotonic()\n    result = PlateResult(duration_seconds=0.0, files_generated=0, errors=[], output_files=[])\n\n    # Await schema extraction before rendering\n    self._provider_schema = await self._extract_provider_schema()\n\n    # Track unique bundles processed\n    processed_bundles: set[str] = set()\n\n    for component_type in component_types:\n        components = self.registry.get_components_with_templates(component_type)\n        logger.info(f\"Generating docs for {len(components)} {component_type.value} components\")\n\n        # Track unique bundle directories\n        for component in components:\n            processed_bundles.add(str(component.plating_dir))\n\n        files_before = result.files_generated\n        await render_component_docs(\n            components,\n            component_type,\n            final_output_dir,\n            force,\n            result,\n            self.context,\n            self._provider_schema or {},\n        )\n        files_for_type = result.files_generated - files_before\n        if files_for_type &gt; 0:\n            logger.info(f\"Generated {files_for_type} {component_type.value} documentation files\")\n\n    # Generate provider index page\n    pout(\"\ud83d\udcdd Generating provider index...\")\n    generate_provider_index(\n        final_output_dir, force, result, self.context, self._provider_schema or {}, self.registry\n    )\n\n    # Update result with tracking info\n    result.bundles_processed = len(processed_bundles)\n    result.duration_seconds = time.monotonic() - start_time\n\n    # Validate if requested (disabled due to markdown validator dependency)\n    # if validate_markdown and result.output_files:\n    #     validation_result = await self.validate(output_dir, component_types)\n    #     result.errors.extend(validation_result.errors)\n\n    return result\n</code></pre>"},{"location":"api/#plating.Plating.validate","title":"validate  <code>async</code>","text":"<pre><code>validate(\n    output_dir: Path | None = None,\n    component_types: list[ComponentType] | None = None,\n    project_root: Path | None = None,\n) -&gt; ValidationResult\n</code></pre> <p>Validate generated documentation.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>Path | None</code> <p>Directory containing documentation</p> <code>None</code> <code>component_types</code> <code>list[ComponentType] | None</code> <p>Component types to validate</p> <code>None</code> <code>project_root</code> <code>Path | None</code> <p>Project root directory (auto-detected if not provided)</p> <code>None</code> <p>Returns:</p> Type Description <code>ValidationResult</code> <p>ValidationResult with any errors found</p> Source code in <code>src/plating/plating.py</code> <pre><code>@with_timing\n@with_metrics(\"validate\")\nasync def validate(\n    self,\n    output_dir: Path | None = None,\n    component_types: list[ComponentType] | None = None,\n    project_root: Path | None = None,\n) -&gt; ValidationResult:\n    \"\"\"Validate generated documentation.\n\n    Args:\n        output_dir: Directory containing documentation\n        component_types: Component types to validate\n        project_root: Project root directory (auto-detected if not provided)\n\n    Returns:\n        ValidationResult with any errors found\n    \"\"\"\n    # Use same logic as plate method for consistency\n    if project_root is None:\n        project_root = find_project_root()\n\n    final_output_dir = get_output_directory(output_dir, project_root)\n    component_types = component_types or [\n        ComponentType.RESOURCE,\n        ComponentType.DATA_SOURCE,\n        ComponentType.FUNCTION,\n    ]\n\n    errors = []\n    files_checked = 0\n    passed = 0\n\n    for component_type in component_types:\n        type_dir = final_output_dir / component_type.output_subdir\n        if not type_dir.exists():\n            continue\n\n        for md_file in type_dir.glob(\"*.md\"):\n            try:\n                # For now, just simulate validation (since markdown validator is disabled)\n                files_checked += 1\n                passed += 1  # Assume validation passes\n            except Exception as e:\n                errors.append(f\"Failed to validate {md_file}: {e}\")\n\n    return ValidationResult(\n        total=files_checked,\n        passed=passed,\n        failed=len(errors),\n        skipped=0,\n        duration_seconds=0.0,\n        errors=errors,\n    )\n</code></pre>"},{"location":"api/#plating.Plating.get_registry_stats","title":"get_registry_stats","text":"<pre><code>get_registry_stats() -&gt; dict[str, Any]\n</code></pre> <p>Get registry statistics.</p> Source code in <code>src/plating/plating.py</code> <pre><code>def get_registry_stats(self) -&gt; dict[str, Any]:\n    \"\"\"Get registry statistics.\"\"\"\n    stats = {\"total_components\": 0, \"component_types\": []}\n\n    for component_type in [ComponentType.RESOURCE, ComponentType.DATA_SOURCE, ComponentType.FUNCTION]:\n        components = self.registry.get_components(component_type)\n        with_templates = self.registry.get_components_with_templates(component_type)\n\n        stats[component_type.value] = {\n            \"total\": len(components),\n            \"with_templates\": len(with_templates),\n        }\n        stats[\"total_components\"] += len(components)\n        if components:\n            stats[\"component_types\"].append(component_type.value)\n\n    return stats\n</code></pre>"},{"location":"api/#plating.PlatingRegistry","title":"PlatingRegistry","text":"<pre><code>PlatingRegistry(package_name: str | None = None)\n</code></pre> <p>               Bases: <code>Registry</code></p> <p>Component registry using foundation Registry pattern with ComponentSet support.</p> <p>Initialize registry with package discovery.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str | None</code> <p>Package to search for plating bundles, or None to search all packages</p> <code>None</code> Source code in <code>src/plating/registry.py</code> <pre><code>def __init__(self, package_name: str | None = None) -&gt; None:\n    \"\"\"Initialize registry with package discovery.\n\n    Args:\n        package_name: Package to search for plating bundles, or None to search all packages\n    \"\"\"\n    super().__init__()\n    self.package_name = package_name\n\n    # Foundation resilience for discovery\n    self._retry_policy = RetryPolicy(\n        max_attempts=3,\n        backoff=BackoffStrategy.EXPONENTIAL,\n        base_delay=0.5,\n        max_delay=5.0,\n        retryable_errors=(OSError, ImportError, AttributeError),\n    )\n    self._retry_executor = RetryExecutor(self._retry_policy)\n\n    # Initialize discovery with error handling\n    try:\n        self._discovery = PlatingDiscovery(package_name)\n        # Auto-discover on initialization\n        self._discover_and_register()\n    except Exception as e:\n        scope = package_name if package_name else \"all packages\"\n        logger.error(f\"Failed to initialize discovery for {scope}: {e}\")\n        # Set discovery to None so we can still create the registry\n        self._discovery = None\n</code></pre>"},{"location":"api/#plating.PlatingRegistry-attributes","title":"Attributes","text":""},{"location":"api/#plating.PlatingRegistry.package_name","title":"package_name  <code>instance-attribute</code>","text":"<pre><code>package_name = package_name\n</code></pre>"},{"location":"api/#plating.PlatingRegistry-functions","title":"Functions","text":""},{"location":"api/#plating.PlatingRegistry.get_components","title":"get_components","text":"<pre><code>get_components(\n    component_type: ComponentType,\n) -&gt; list[PlatingBundle]\n</code></pre> <p>Get all components of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <code>ComponentType</code> <p>The component type to filter by</p> required <p>Returns:</p> Type Description <code>list[PlatingBundle]</code> <p>List of PlatingBundle objects</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_components(self, component_type: ComponentType) -&gt; list[PlatingBundle]:\n    \"\"\"Get all components of a specific type.\n\n    Args:\n        component_type: The component type to filter by\n\n    Returns:\n        List of PlatingBundle objects\n    \"\"\"\n    names = self.list_dimension(component_type.value)\n    entries = []\n    for name in names:\n        entry = self.get_entry(name=name, dimension=component_type.value)\n        if entry:\n            entries.append(entry)\n    return [entry.value.bundle for entry in entries]\n</code></pre>"},{"location":"api/#plating.PlatingRegistry.get_component","title":"get_component","text":"<pre><code>get_component(\n    component_type: ComponentType, name: str\n) -&gt; PlatingBundle | None\n</code></pre> <p>Get a specific component by type and name.</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <code>ComponentType</code> <p>The component type</p> required <code>name</code> <code>str</code> <p>The component name</p> required <p>Returns:</p> Type Description <code>PlatingBundle | None</code> <p>PlatingBundle if found, None otherwise</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_component(self, component_type: ComponentType, name: str) -&gt; PlatingBundle | None:\n    \"\"\"Get a specific component by type and name.\n\n    Args:\n        component_type: The component type\n        name: The component name\n\n    Returns:\n        PlatingBundle if found, None otherwise\n    \"\"\"\n    entry = self.get_entry(name=name, dimension=component_type.value)\n    return entry.value.bundle if entry else None\n</code></pre>"},{"location":"api/#plating.PlatingRegistry.get_components_with_templates","title":"get_components_with_templates","text":"<pre><code>get_components_with_templates(\n    component_type: ComponentType,\n) -&gt; list[PlatingBundle]\n</code></pre> <p>Get components of a type that have templates.</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <code>ComponentType</code> <p>The component type to filter by</p> required <p>Returns:</p> Type Description <code>list[PlatingBundle]</code> <p>List of PlatingBundle objects with templates</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_components_with_templates(self, component_type: ComponentType) -&gt; list[PlatingBundle]:\n    \"\"\"Get components of a type that have templates.\n\n    Args:\n        component_type: The component type to filter by\n\n    Returns:\n        List of PlatingBundle objects with templates\n    \"\"\"\n    components = self.get_components(component_type)\n    return [bundle for bundle in components if bundle.has_main_template()]\n</code></pre>"},{"location":"api/#plating.PlatingRegistry.get_components_with_examples","title":"get_components_with_examples","text":"<pre><code>get_components_with_examples(\n    component_type: ComponentType,\n) -&gt; list[PlatingBundle]\n</code></pre> <p>Get components of a type that have examples.</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <code>ComponentType</code> <p>The component type to filter by</p> required <p>Returns:</p> Type Description <code>list[PlatingBundle]</code> <p>List of PlatingBundle objects with examples</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_components_with_examples(self, component_type: ComponentType) -&gt; list[PlatingBundle]:\n    \"\"\"Get components of a type that have examples.\n\n    Args:\n        component_type: The component type to filter by\n\n    Returns:\n        List of PlatingBundle objects with examples\n    \"\"\"\n    components = self.get_components(component_type)\n    return [bundle for bundle in components if bundle.has_examples()]\n</code></pre>"},{"location":"api/#plating.PlatingRegistry.get_all_component_types","title":"get_all_component_types","text":"<pre><code>get_all_component_types() -&gt; list[ComponentType]\n</code></pre> <p>Get all registered component types.</p> <p>Returns:</p> Type Description <code>list[ComponentType]</code> <p>List of ComponentType enums found in registry</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_all_component_types(self) -&gt; list[ComponentType]:\n    \"\"\"Get all registered component types.\n\n    Returns:\n        List of ComponentType enums found in registry\n    \"\"\"\n    dimensions = self.list_all().keys()\n    component_types = []\n\n    for dimension in dimensions:\n        try:\n            comp_type = ComponentType(dimension)\n            component_types.append(comp_type)\n        except ValueError:\n            # Skip unknown component types\n            pass\n\n    return component_types\n</code></pre>"},{"location":"api/#plating.PlatingRegistry.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refresh the registry by re-discovering components.</p> Source code in <code>src/plating/registry.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refresh the registry by re-discovering components.\"\"\"\n    logger.info(\"Refreshing plating registry\")\n    self.clear()\n    self._discover_and_register()\n</code></pre>"},{"location":"api/#plating.PlatingRegistry.get_registry_stats","title":"get_registry_stats","text":"<pre><code>get_registry_stats() -&gt; dict[str, Any]\n</code></pre> <p>Get statistics about the registry contents.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with registry statistics</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_registry_stats(self) -&gt; dict[str, Any]:\n    \"\"\"Get statistics about the registry contents.\n\n    Returns:\n        Dictionary with registry statistics\n    \"\"\"\n    stats = {}\n    all_names = self.list_all()\n\n    stats[\"total_components\"] = sum(len(names) for names in all_names.values())\n    stats[\"component_types\"] = list(all_names.keys())\n\n    for comp_type, names in all_names.items():\n        stats[f\"{comp_type}_count\"] = len(names)\n\n        # Get actual entries to access metadata\n        entries = []\n        for name in names:\n            entry = self.get_entry(name=name, dimension=comp_type)\n            if entry:\n                entries.append(entry)\n\n        # Count bundles with templates/examples\n        bundles_with_templates = sum(\n            1 for entry in entries if entry.value.metadata.get(\"has_template\", False)\n        )\n        bundles_with_examples = sum(\n            1 for entry in entries if entry.value.metadata.get(\"has_examples\", False)\n        )\n\n        stats[f\"{comp_type}_with_templates\"] = bundles_with_templates\n        stats[f\"{comp_type}_with_examples\"] = bundles_with_examples\n\n    return stats\n</code></pre>"},{"location":"api/#plating.AsyncTemplateEngine","title":"AsyncTemplateEngine","text":"<pre><code>AsyncTemplateEngine()\n</code></pre> <p>Async-first template engine with foundation integration.</p> Source code in <code>src/plating/templating/engine.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._jinja_env = None\n    self._template_cache: dict[str, str] = {}\n</code></pre>"},{"location":"api/#plating.AsyncTemplateEngine-functions","title":"Functions","text":""},{"location":"api/#plating.AsyncTemplateEngine.render","title":"render  <code>async</code>","text":"<pre><code>render(\n    bundle: PlatingBundle, context: PlatingContext\n) -&gt; str\n</code></pre> <p>Render template with context and partials.</p> <p>Parameters:</p> Name Type Description Default <code>bundle</code> <code>PlatingBundle</code> <p>PlatingBundle containing template and assets</p> required <code>context</code> <code>PlatingContext</code> <p>Type-safe context for rendering</p> required <p>Returns:</p> Type Description <code>str</code> <p>Rendered template string</p> <p>Raises:</p> Type Description <code>TemplateError</code> <p>If template rendering fails</p> <code>FileSystemError</code> <p>If template loading fails</p> Source code in <code>src/plating/templating/engine.py</code> <pre><code>@with_timing\n@with_metrics(\"template_render\")\nasync def render(self, bundle: PlatingBundle, context: PlatingContext) -&gt; str:\n    \"\"\"Render template with context and partials.\n\n    Args:\n        bundle: PlatingBundle containing template and assets\n        context: Type-safe context for rendering\n\n    Returns:\n        Rendered template string\n\n    Raises:\n        TemplateError: If template rendering fails\n        FileSystemError: If template loading fails\n    \"\"\"\n    try:\n        # Load template and partials concurrently\n        template_task = asyncio.create_task(self._load_template(bundle))\n        partials_task = asyncio.create_task(self._load_partials(bundle))\n\n        template_content, partials = await asyncio.gather(template_task, partials_task)\n\n        if not template_content:\n            logger.debug(f\"No template found for {bundle.name}, skipping\")\n            return \"\"\n\n        # Prepare templates dict\n        templates = {\"main.tmpl\": template_content}\n        templates.update(partials)\n\n        # Create Jinja environment\n        env = self._get_jinja_env(templates)\n\n        # Convert context to dict\n        context_dict = context.to_dict()\n\n        # Override template functions with context-aware implementations\n        env.globals[\"example\"] = lambda key: self._format_example_with_context(key, context.examples)\n\n        # Override schema function to return actual schema\n        if context.schema:\n            env.globals[\"schema\"] = lambda: context.schema.to_markdown()\n        else:\n            env.globals[\"schema\"] = lambda: \"\"\n\n        # Render template asynchronously\n        template = env.get_template(\"main.tmpl\")\n\n        async with plating_metrics.track_operation(\"template_render\", bundle=bundle.name):\n            return await template.render_async(**context_dict)\n\n    except Jinja2TemplateError as e:\n        # Extract line number if available\n        line_number = getattr(e, \"lineno\", None)\n        error_msg = str(e)\n\n        logger.error(\n            \"Template rendering failed\",\n            bundle=bundle.name,\n            error=error_msg,\n            line_number=line_number,\n            **context.to_dict(),\n        )\n\n        raise TemplateError(\n            template_path=bundle.plating_dir / \"docs\" / f\"{bundle.name}.tmpl.md\",\n            reason=error_msg,\n            line_number=line_number,\n            context=getattr(e, \"source\", None),\n        ) from e\n\n    except OSError as e:\n        logger.error(\"File system error during template rendering\", bundle=bundle.name, error=str(e))\n        raise FileSystemError(\n            path=bundle.plating_dir,\n            operation=\"read template\",\n            reason=str(e),\n            caused_by=e,\n        ) from e\n\n    except Exception as e:\n        logger.exception(\"Unexpected error during template rendering\", bundle=bundle.name)\n        raise TemplateError(\n            template_path=bundle.plating_dir / \"docs\" / f\"{bundle.name}.tmpl.md\",\n            reason=f\"Unexpected error: {type(e).__name__}: {e}\",\n        ) from e\n</code></pre>"},{"location":"api/#plating.AsyncTemplateEngine.render_batch","title":"render_batch  <code>async</code>","text":"<pre><code>render_batch(\n    items: list[tuple[PlatingBundle, PlatingContext]],\n) -&gt; list[str]\n</code></pre> <p>Render multiple templates in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[tuple[PlatingBundle, PlatingContext]]</code> <p>List of (bundle, context) tuples to render</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of rendered template strings</p> <p>Raises:</p> Type Description <code>TemplateError</code> <p>If any template rendering fails</p> <code>FileSystemError</code> <p>If any template loading fails</p> Source code in <code>src/plating/templating/engine.py</code> <pre><code>@with_timing\n@with_metrics(\"template_render_batch\")\nasync def render_batch(self, items: list[tuple[PlatingBundle, PlatingContext]]) -&gt; list[str]:\n    \"\"\"Render multiple templates in parallel.\n\n    Args:\n        items: List of (bundle, context) tuples to render\n\n    Returns:\n        List of rendered template strings\n\n    Raises:\n        TemplateError: If any template rendering fails\n        FileSystemError: If any template loading fails\n    \"\"\"\n    tasks = [asyncio.create_task(self.render(bundle, context)) for bundle, context in items]\n\n    async with plating_metrics.track_operation(\"batch_render\", count=len(items)):\n        return await asyncio.gather(*tasks)\n</code></pre>"},{"location":"api/#plating.AsyncTemplateEngine.clear_cache","title":"clear_cache","text":"<pre><code>clear_cache() -&gt; None\n</code></pre> <p>Clear template cache.</p> Source code in <code>src/plating/templating/engine.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear template cache.\"\"\"\n    self._template_cache.clear()\n</code></pre>"},{"location":"api/#plating.TemplateMetadataExtractor","title":"TemplateMetadataExtractor","text":"<pre><code>TemplateMetadataExtractor()\n</code></pre> <p>Extracts metadata from function implementations for template rendering.</p> Source code in <code>src/plating/templating/metadata.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.config = get_config()\n</code></pre>"},{"location":"api/#plating.TemplateMetadataExtractor-attributes","title":"Attributes","text":""},{"location":"api/#plating.TemplateMetadataExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = get_config()\n</code></pre>"},{"location":"api/#plating.TemplateMetadataExtractor-functions","title":"Functions","text":""},{"location":"api/#plating.TemplateMetadataExtractor.extract_function_metadata","title":"extract_function_metadata","text":"<pre><code>extract_function_metadata(\n    function_name: str, component_type: str\n) -&gt; dict[str, Any]\n</code></pre> <p>Extract metadata for a function to populate templates.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>str</code> <p>Name of the function</p> required <code>component_type</code> <code>str</code> <p>Type of component (function, resource, etc.)</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing metadata for template rendering</p> Source code in <code>src/plating/templating/metadata.py</code> <pre><code>def extract_function_metadata(self, function_name: str, component_type: str) -&gt; dict[str, Any]:\n    \"\"\"Extract metadata for a function to populate templates.\n\n    Args:\n        function_name: Name of the function\n        component_type: Type of component (function, resource, etc.)\n\n    Returns:\n        Dictionary containing metadata for template rendering\n    \"\"\"\n    return self._generate_function_metadata(function_name)\n</code></pre>"},{"location":"api/#plating.TemplateMetadataExtractor.discover_template_files","title":"discover_template_files","text":"<pre><code>discover_template_files(docs_dir: Path) -&gt; list[Path]\n</code></pre> <p>Discover all template files in a docs directory.</p> <p>Parameters:</p> Name Type Description Default <code>docs_dir</code> <code>Path</code> <p>Directory containing template files</p> required <p>Returns:</p> Type Description <code>list[Path]</code> <p>List of template file paths</p> Source code in <code>src/plating/templating/metadata.py</code> <pre><code>def discover_template_files(self, docs_dir: Path) -&gt; list[Path]:\n    \"\"\"Discover all template files in a docs directory.\n\n    Args:\n        docs_dir: Directory containing template files\n\n    Returns:\n        List of template file paths\n    \"\"\"\n    if not docs_dir.exists():\n        return []\n\n    template_files = []\n    for template_file in docs_dir.glob(\"*.tmpl.md\"):\n        template_files.append(template_file)\n\n    return template_files\n</code></pre>"},{"location":"api/#plating.AdornResult","title":"AdornResult","text":"<p>Result from adorn operations.</p>"},{"location":"api/#plating.AdornResult-attributes","title":"Attributes","text":""},{"location":"api/#plating.AdornResult.components_processed","title":"components_processed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>components_processed: int = 0\n</code></pre>"},{"location":"api/#plating.AdornResult.templates_generated","title":"templates_generated  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>templates_generated: int = 0\n</code></pre>"},{"location":"api/#plating.AdornResult.examples_created","title":"examples_created  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>examples_created: int = 0\n</code></pre>"},{"location":"api/#plating.AdornResult.errors","title":"errors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>errors: list[str] = field(factory=list)\n</code></pre>"},{"location":"api/#plating.AdornResult.success","title":"success  <code>property</code>","text":"<pre><code>success: bool\n</code></pre> <p>Whether the operation succeeded.</p>"},{"location":"api/#plating.ArgumentInfo","title":"ArgumentInfo","text":"<p>Information about a function argument.</p>"},{"location":"api/#plating.ArgumentInfo-attributes","title":"Attributes","text":""},{"location":"api/#plating.ArgumentInfo.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/#plating.ArgumentInfo.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str\n</code></pre>"},{"location":"api/#plating.ArgumentInfo.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre>"},{"location":"api/#plating.ArgumentInfo.required","title":"required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>required: bool = True\n</code></pre>"},{"location":"api/#plating.ArgumentInfo-functions","title":"Functions","text":""},{"location":"api/#plating.ArgumentInfo.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert to dictionary for serialization.</p> Source code in <code>src/plating/types.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert to dictionary for serialization.\"\"\"\n    return {\n        \"name\": self.name,\n        \"type\": self.type,\n        \"description\": self.description,\n        \"required\": self.required,\n    }\n</code></pre>"},{"location":"api/#plating.ArgumentInfo.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[str, Any]) -&gt; ArgumentInfo\n</code></pre> <p>Create from dictionary.</p> Source code in <code>src/plating/types.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; \"ArgumentInfo\":\n    \"\"\"Create from dictionary.\"\"\"\n    return cls(\n        name=data.get(\"name\", \"\"),\n        type=data.get(\"type\", \"\"),\n        description=data.get(\"description\", \"\"),\n        required=data.get(\"required\", True),\n    )\n</code></pre>"},{"location":"api/#plating.ComponentType","title":"ComponentType","text":"<p>               Bases: <code>Enum</code></p> <p>Type-safe component types for Terraform/OpenTofu providers.</p> <p>Supported types: - RESOURCE: Terraform resources - DATA_SOURCE: Terraform data sources - FUNCTION: Provider-defined functions - PROVIDER: Provider configuration</p>"},{"location":"api/#plating.ComponentType-attributes","title":"Attributes","text":""},{"location":"api/#plating.ComponentType.RESOURCE","title":"RESOURCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESOURCE = 'resource'\n</code></pre>"},{"location":"api/#plating.ComponentType.DATA_SOURCE","title":"DATA_SOURCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATA_SOURCE = 'data_source'\n</code></pre>"},{"location":"api/#plating.ComponentType.FUNCTION","title":"FUNCTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FUNCTION = 'function'\n</code></pre>"},{"location":"api/#plating.ComponentType.PROVIDER","title":"PROVIDER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROVIDER = 'provider'\n</code></pre>"},{"location":"api/#plating.ComponentType.display_name","title":"display_name  <code>property</code>","text":"<pre><code>display_name: str\n</code></pre> <p>Get the formatted display name.</p>"},{"location":"api/#plating.ComponentType.output_subdir","title":"output_subdir  <code>property</code>","text":"<pre><code>output_subdir: str\n</code></pre> <p>Get the output subdirectory name for Terraform Registry structure.</p>"},{"location":"api/#plating.PlateResult","title":"PlateResult","text":"<p>Result from plate operations.</p>"},{"location":"api/#plating.PlateResult-attributes","title":"Attributes","text":""},{"location":"api/#plating.PlateResult.bundles_processed","title":"bundles_processed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bundles_processed: int = 0\n</code></pre>"},{"location":"api/#plating.PlateResult.files_generated","title":"files_generated  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files_generated: int = 0\n</code></pre>"},{"location":"api/#plating.PlateResult.duration_seconds","title":"duration_seconds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duration_seconds: float = 0.0\n</code></pre>"},{"location":"api/#plating.PlateResult.errors","title":"errors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>errors: list[str] = field(factory=list)\n</code></pre>"},{"location":"api/#plating.PlateResult.output_files","title":"output_files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_files: list[Path] = field(factory=list)\n</code></pre>"},{"location":"api/#plating.PlateResult.success","title":"success  <code>property</code>","text":"<pre><code>success: bool\n</code></pre> <p>Whether the operation succeeded.</p>"},{"location":"api/#plating.SchemaInfo","title":"SchemaInfo","text":"<p>Structured schema information.</p>"},{"location":"api/#plating.SchemaInfo-attributes","title":"Attributes","text":""},{"location":"api/#plating.SchemaInfo.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre>"},{"location":"api/#plating.SchemaInfo.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, dict[str, Any]] = field(factory=dict)\n</code></pre>"},{"location":"api/#plating.SchemaInfo.blocks","title":"blocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocks: dict[str, dict[str, Any]] = field(factory=dict)\n</code></pre>"},{"location":"api/#plating.SchemaInfo.test_only","title":"test_only  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>test_only: bool = False\n</code></pre>"},{"location":"api/#plating.SchemaInfo.component_of","title":"component_of  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>component_of: str | None = None\n</code></pre>"},{"location":"api/#plating.SchemaInfo-functions","title":"Functions","text":""},{"location":"api/#plating.SchemaInfo.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(schema_dict: dict[str, Any]) -&gt; SchemaInfo\n</code></pre> <p>Create SchemaInfo from a raw schema dictionary.</p> Source code in <code>src/plating/types.py</code> <pre><code>@classmethod\ndef from_dict(cls, schema_dict: dict[str, Any]) -&gt; \"SchemaInfo\":\n    \"\"\"Create SchemaInfo from a raw schema dictionary.\"\"\"\n    if not schema_dict:\n        return cls()\n\n    block = schema_dict.get(\"block\", {})\n    return cls(\n        description=schema_dict.get(\"description\", \"\"),\n        attributes=block.get(\"attributes\", {}),\n        blocks=block.get(\"block_types\", {}),\n        test_only=schema_dict.get(\"test_only\", False),\n        component_of=schema_dict.get(\"component_of\"),\n    )\n</code></pre>"},{"location":"api/#plating.SchemaInfo.to_markdown","title":"to_markdown","text":"<pre><code>to_markdown() -&gt; str\n</code></pre> <p>Convert schema to markdown format.</p> Source code in <code>src/plating/types.py</code> <pre><code>def to_markdown(self) -&gt; str:\n    \"\"\"Convert schema to markdown format.\"\"\"\n    if not self.attributes and not self.blocks:\n        return \"\"\n\n    lines = [\"## Schema\", \"\"]\n\n    # Group attributes by type\n    required_attrs = []\n    optional_attrs = []\n    computed_attrs = []\n\n    for attr_name, attr_def in self.attributes.items():\n        attr_type = self._format_type(attr_def.get(\"type\"))\n        description = attr_def.get(\"description\", \"\")\n\n        if attr_def.get(\"required\"):\n            required_attrs.append((attr_name, attr_type, description))\n        elif attr_def.get(\"computed\") and not attr_def.get(\"optional\"):\n            computed_attrs.append((attr_name, attr_type, description))\n        else:\n            optional_attrs.append((attr_name, attr_type, description))\n\n    # Format sections\n    if required_attrs:\n        lines.extend([\"### Required\", \"\"])\n        for name, type_str, desc in required_attrs:\n            lines.append(f\"- `{name}` ({type_str}) - {desc}\")\n        lines.append(\"\")\n\n    if optional_attrs:\n        lines.extend([\"### Optional\", \"\"])\n        for name, type_str, desc in optional_attrs:\n            lines.append(f\"- `{name}` ({type_str}) - {desc}\")\n        lines.append(\"\")\n\n    if computed_attrs:\n        lines.extend([\"### Read-Only\", \"\"])\n        for name, type_str, desc in computed_attrs:\n            lines.append(f\"- `{name}` ({type_str}) - {desc}\")\n        lines.append(\"\")\n\n    # Handle nested blocks\n    if self.blocks:\n        lines.extend([\"### Blocks\", \"\"])\n        for block_name, block_def in self.blocks.items():\n            max_items = block_def.get(\"max_items\", 0)\n            if max_items == 1:\n                lines.append(f\"- `{block_name}` (Optional)\")\n            else:\n                lines.append(f\"- `{block_name}` (Optional, List)\")\n        lines.append(\"\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/#plating.ValidationResult","title":"ValidationResult","text":"<p>Result from validation operations with markdown linting support.</p>"},{"location":"api/#plating.ValidationResult-attributes","title":"Attributes","text":""},{"location":"api/#plating.ValidationResult.total","title":"total  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total: int = 0\n</code></pre>"},{"location":"api/#plating.ValidationResult.passed","title":"passed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>passed: int = 0\n</code></pre>"},{"location":"api/#plating.ValidationResult.failed","title":"failed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>failed: int = 0\n</code></pre>"},{"location":"api/#plating.ValidationResult.skipped","title":"skipped  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>skipped: int = 0\n</code></pre>"},{"location":"api/#plating.ValidationResult.duration_seconds","title":"duration_seconds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duration_seconds: float = 0.0\n</code></pre>"},{"location":"api/#plating.ValidationResult.failures","title":"failures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>failures: dict[str, str] = field(factory=dict)\n</code></pre>"},{"location":"api/#plating.ValidationResult.errors","title":"errors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>errors: list[str] = field(factory=list)\n</code></pre>"},{"location":"api/#plating.ValidationResult.lint_errors","title":"lint_errors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lint_errors: list[str] = field(factory=list)\n</code></pre>"},{"location":"api/#plating.ValidationResult.terraform_version","title":"terraform_version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>terraform_version: str = ''\n</code></pre>"},{"location":"api/#plating.ValidationResult.success","title":"success  <code>property</code>","text":"<pre><code>success: bool\n</code></pre> <p>Whether all validations passed.</p>"},{"location":"api/#plating-functions","title":"Functions","text":""},{"location":"api/#plating.with_circuit_breaker","title":"with_circuit_breaker","text":"<pre><code>with_circuit_breaker(\n    failure_threshold: int = 3,\n    recovery_timeout: float = 30.0,\n    expected_exception: type[Exception] = Exception,\n) -&gt; Callable[[F], F]\n</code></pre> <p>Decorator for circuit breaker protection.</p> <p>Parameters:</p> Name Type Description Default <code>failure_threshold</code> <code>int</code> <p>Number of failures before opening circuit</p> <code>3</code> <code>recovery_timeout</code> <code>float</code> <p>Time to wait before attempting recovery</p> <code>30.0</code> <code>expected_exception</code> <code>type[Exception]</code> <p>Exception type that triggers circuit breaker</p> <code>Exception</code> Source code in <code>src/plating/decorators.py</code> <pre><code>def with_circuit_breaker(\n    failure_threshold: int = 3, recovery_timeout: float = 30.0, expected_exception: type[Exception] = Exception\n) -&gt; Callable[[F], F]:\n    \"\"\"Decorator for circuit breaker protection.\n\n    Args:\n        failure_threshold: Number of failures before opening circuit\n        recovery_timeout: Time to wait before attempting recovery\n        expected_exception: Exception type that triggers circuit breaker\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        circuit = SyncCircuitBreaker(\n            failure_threshold=failure_threshold,\n            recovery_timeout=recovery_timeout,\n            expected_exception=expected_exception,\n        )\n\n        if asyncio.iscoroutinefunction(func):\n\n            @functools.wraps(func)\n            async def async_wrapper(*args, **kwargs):\n                return await circuit.call_async(func, *args, **kwargs)\n\n            return async_wrapper\n        else:\n\n            @functools.wraps(func)\n            def sync_wrapper(*args, **kwargs):\n                return circuit.call(func, *args, **kwargs)\n\n            return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/#plating.with_metrics","title":"with_metrics","text":"<pre><code>with_metrics(operation_name: str) -&gt; Callable[[F], F]\n</code></pre> <p>Decorator for automatic metrics collection via structured logging.</p> <p>Parameters:</p> Name Type Description Default <code>operation_name</code> <code>str</code> <p>Name for the operation metrics</p> required Source code in <code>src/plating/decorators.py</code> <pre><code>def with_metrics(operation_name: str) -&gt; Callable[[F], F]:\n    \"\"\"Decorator for automatic metrics collection via structured logging.\n\n    Args:\n        operation_name: Name for the operation metrics\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        if asyncio.iscoroutinefunction(func):\n\n            @functools.wraps(func)\n            async def async_wrapper(*args, **kwargs):\n                start = time.perf_counter()\n                try:\n                    result = await func(*args, **kwargs)\n                    duration = time.perf_counter() - start\n                    logger.info(\n                        f\"Operation {operation_name} completed\",\n                        operation=operation_name,\n                        status=\"success\",\n                        duration_seconds=duration,\n                    )\n                    return result\n                except Exception as e:\n                    duration = time.perf_counter() - start\n                    logger.error(\n                        f\"Operation {operation_name} failed\",\n                        operation=operation_name,\n                        status=\"error\",\n                        error=type(e).__name__,\n                        duration_seconds=duration,\n                    )\n                    raise\n\n            return async_wrapper\n        else:\n\n            @functools.wraps(func)\n            def sync_wrapper(*args, **kwargs):\n                start = time.perf_counter()\n                try:\n                    result = func(*args, **kwargs)\n                    duration = time.perf_counter() - start\n                    logger.info(\n                        f\"Operation {operation_name} completed\",\n                        operation=operation_name,\n                        status=\"success\",\n                        duration_seconds=duration,\n                    )\n                    return result\n                except Exception as e:\n                    duration = time.perf_counter() - start\n                    logger.error(\n                        f\"Operation {operation_name} failed\",\n                        operation=operation_name,\n                        status=\"error\",\n                        error=type(e).__name__,\n                        duration_seconds=duration,\n                    )\n                    raise\n\n            return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/#plating.with_retry","title":"with_retry","text":"<pre><code>with_retry(\n    max_attempts: int = 3,\n    backoff: str = \"exponential\",\n    base_delay: float = 1.0,\n    max_delay: float = 60.0,\n    retryable_errors: tuple[type[Exception], ...] = (\n        Exception,\n    ),\n) -&gt; Callable[[F], F]\n</code></pre> <p>Decorator for automatic retry with exponential backoff.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <code>int</code> <p>Maximum number of retry attempts</p> <code>3</code> <code>backoff</code> <code>str</code> <p>Backoff strategy (\"exponential\", \"linear\", \"constant\")</p> <code>'exponential'</code> <code>base_delay</code> <code>float</code> <p>Base delay between retries</p> <code>1.0</code> <code>max_delay</code> <code>float</code> <p>Maximum delay between retries</p> <code>60.0</code> <code>retryable_errors</code> <code>tuple[type[Exception], ...]</code> <p>Tuple of exception types that should trigger retry</p> <code>(Exception,)</code> Source code in <code>src/plating/decorators.py</code> <pre><code>def with_retry(\n    max_attempts: int = 3,\n    backoff: str = \"exponential\",\n    base_delay: float = 1.0,\n    max_delay: float = 60.0,\n    retryable_errors: tuple[type[Exception], ...] = (Exception,),\n) -&gt; Callable[[F], F]:\n    \"\"\"Decorator for automatic retry with exponential backoff.\n\n    Args:\n        max_attempts: Maximum number of retry attempts\n        backoff: Backoff strategy (\"exponential\", \"linear\", \"constant\")\n        base_delay: Base delay between retries\n        max_delay: Maximum delay between retries\n        retryable_errors: Tuple of exception types that should trigger retry\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        # Convert string to BackoffStrategy enum\n        backoff_strategy = {\n            \"exponential\": BackoffStrategy.EXPONENTIAL,\n            \"linear\": BackoffStrategy.LINEAR,\n            \"fixed\": BackoffStrategy.FIXED,\n            \"constant\": BackoffStrategy.FIXED,  # Map constant to fixed\n        }.get(backoff, BackoffStrategy.EXPONENTIAL)\n\n        retry_policy = RetryPolicy(\n            max_attempts=max_attempts,\n            backoff=backoff_strategy,\n            base_delay=base_delay,\n            max_delay=max_delay,\n            retryable_errors=retryable_errors,\n        )\n        retry_executor = RetryExecutor(retry_policy)\n\n        if asyncio.iscoroutinefunction(func):\n\n            @functools.wraps(func)\n            async def async_wrapper(*args, **kwargs):\n                return await retry_executor.execute_async(func, *args, **kwargs)\n\n            return async_wrapper\n        else:\n\n            @functools.wraps(func)\n            def sync_wrapper(*args, **kwargs):\n                return retry_executor.execute_sync(func, *args, **kwargs)\n\n            return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/#plating.with_timing","title":"with_timing","text":"<pre><code>with_timing(func: F) -&gt; F\n</code></pre> <p>Decorator for automatic timing with structured logging.</p> <p>Uses foundation's timed_block for consistent timing and logging.</p> Source code in <code>src/plating/decorators.py</code> <pre><code>def with_timing(func: F) -&gt; F:\n    \"\"\"Decorator for automatic timing with structured logging.\n\n    Uses foundation's timed_block for consistent timing and logging.\n    \"\"\"\n    if asyncio.iscoroutinefunction(func):\n\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            from provide.foundation.utils import timed_block\n\n            operation_name = f\"{func.__module__}.{func.__name__}\"\n            with timed_block(logger, operation_name):\n                return await func(*args, **kwargs)\n\n        return async_wrapper\n    else:\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            from provide.foundation.utils import timed_block\n\n            operation_name = f\"{func.__module__}.{func.__name__}\"\n            with timed_block(logger, operation_name):\n                return func(*args, **kwargs)\n\n        return sync_wrapper\n</code></pre>"},{"location":"api/#plating.get_plating_registry","title":"get_plating_registry","text":"<pre><code>get_plating_registry(\n    package_name: str | None = None,\n) -&gt; PlatingRegistry\n</code></pre> <p>Get or create the global plating registry.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str | None</code> <p>Package to search for components, or None to search all packages</p> <code>None</code> <p>Returns:</p> Type Description <code>PlatingRegistry</code> <p>PlatingRegistry instance</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_plating_registry(package_name: str | None = None) -&gt; PlatingRegistry:\n    \"\"\"Get or create the global plating registry.\n\n    Args:\n        package_name: Package to search for components, or None to search all packages\n\n    Returns:\n        PlatingRegistry instance\n    \"\"\"\n    global _global_registry\n    if _global_registry is None:\n        _global_registry = PlatingRegistry(package_name)\n    return _global_registry\n</code></pre>"},{"location":"api/#plating.reset_plating_registry","title":"reset_plating_registry","text":"<pre><code>reset_plating_registry() -&gt; None\n</code></pre> <p>Reset the global registry (primarily for testing).</p> Source code in <code>src/plating/registry.py</code> <pre><code>def reset_plating_registry() -&gt; None:\n    \"\"\"Reset the global registry (primarily for testing).\"\"\"\n    global _global_registry\n    _global_registry = None\n</code></pre>"},{"location":"archive/historical/API/","title":"Macro Rendering Error","text":"<p>File: <code>archive/historical/API.md</code></p> <p>UndefinedError: 'schema' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 704, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 105, in top-level template code\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/utils.py\", line 92, in from_obj\n    if hasattr(obj, \"jinja_pass_arg\"):\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'schema' is undefined\n</code></pre>"},{"location":"archive/historical/future/","title":"Future Proposals and Ideas","text":"<p>This directory contains proposals and ideas for future development of the Plating project.</p> <p>\u26a0\ufe0f Important: The documents in this directory describe features and designs that do not currently exist in Plating. They are forward-looking proposals for potential future enhancements.</p>"},{"location":"archive/historical/future/#current-proposals","title":"Current Proposals","text":"Proposal Status Date Description bundle-discovery-pattern.md \ud83d\udca1 Proposal 2025-01-25 Extract Plating's bundle discovery logic into a generic foundation module for reuse across the provide ecosystem template-processing-pipeline.md \ud83d\udca1 Proposal 2025-01-25 Extract Plating's async template engine into a general-purpose foundation module"},{"location":"archive/historical/future/#status-indicators","title":"Status Indicators","text":"<ul> <li>\ud83d\udca1 Proposal - Idea stage, not yet approved for implementation</li> <li>\ud83d\udea7 In Progress - Approved and actively being implemented</li> <li>\u2705 Implemented - Feature has been implemented and merged</li> <li>\u23f8\ufe0f Deferred - Good idea but not a priority right now</li> <li>\u274c Rejected - Decided not to pursue this direction</li> </ul>"},{"location":"archive/historical/future/#contributing-proposals","title":"Contributing Proposals","text":"<p>If you have ideas for future Plating features:</p> <ol> <li>Create a new markdown file in this directory</li> <li>Use a clear, descriptive filename (e.g., <code>schema-caching-system.md</code>)</li> <li>Include:</li> <li>Overview: What problem does this solve?</li> <li>Proposed Solution: How would it work?</li> <li>Benefits: Why implement this?</li> <li> <p>Implementation Notes: Technical considerations</p> </li> <li> <p>Submit as a pull request for discussion</p> </li> </ol>"},{"location":"archive/historical/future/#from-proposal-to-implementation","title":"From Proposal to Implementation","text":"<p>When a proposal is accepted and implemented: 1. Move relevant content to the main documentation 2. Update the proposal file to reference the implemented feature 3. Consider archiving or removing the proposal file</p>"},{"location":"archive/historical/future/bundle-discovery-pattern/","title":"Bundle Discovery Pattern for Foundation","text":"<p>Status: \ud83d\udca1 Proposal Date: 2025-01-25 Implementation: Not yet started Discussion: This is a forward-looking proposal for extracting plating's bundle discovery into foundation</p>"},{"location":"archive/historical/future/bundle-discovery-pattern/#overview","title":"Overview","text":"<p>The <code>PlatingBundle</code> and <code>PlatingDiscovery</code> patterns from plating are generic and reusable for any packaged asset discovery. This could become a foundation module.</p>"},{"location":"archive/historical/future/bundle-discovery-pattern/#proposed-foundation-module-providefoundationdiscovery","title":"Proposed Foundation Module: <code>provide.foundation.discovery</code>","text":""},{"location":"archive/historical/future/bundle-discovery-pattern/#core-classes","title":"Core Classes","text":"<pre><code>@dataclass\nclass ResourceBundle:\n    \"\"\"Generic resource bundle for any packaged assets.\"\"\"\n    name: str\n    bundle_dir: Path\n    resource_type: str\n    metadata: dict[str, Any] = field(default_factory=dict)\n\n    @property\n    def assets_dir(self) -&gt; Path:\n        \"\"\"Directory containing assets.\"\"\"\n        return self.bundle_dir / \"assets\"\n\n    @property  \n    def config_dir(self) -&gt; Path:\n        \"\"\"Directory containing configuration.\"\"\"\n        return self.bundle_dir / \"config\"\n\n    def load_assets(self) -&gt; dict[str, str]:\n        \"\"\"Load all asset files as string content.\"\"\"\n        # Implementation similar to PlatingBundle.load_examples\n\n    def load_metadata(self) -&gt; dict[str, Any]:\n        \"\"\"Load bundle metadata from config files.\"\"\"\n        # Implementation for loading YAML/JSON metadata\n\nclass ResourceDiscovery:\n    \"\"\"Discover resource bundles from installed packages.\"\"\"\n\n    def __init__(self, package_pattern: str = \"*.resources\"):\n        self.package_pattern = package_pattern\n\n    def discover_bundles(self, resource_type: str | None = None) -&gt; list[ResourceBundle]:\n        \"\"\"Discover all resource bundles from packages.\"\"\"\n        # Generic implementation for any package discovery\n\n    def scan_directory(self, directory: Path) -&gt; list[ResourceBundle]:\n        \"\"\"Scan a directory for resource bundles.\"\"\"\n        # Local directory scanning\n</code></pre>"},{"location":"archive/historical/future/bundle-discovery-pattern/#usage-examples","title":"Usage Examples","text":"<pre><code># For documentation generation (current plating use case)\nfrom provide.foundation.discovery import ResourceDiscovery, ResourceBundle\n\ndiscovery = ResourceDiscovery(\"*.components\")  \ndoc_bundles = discovery.discover_bundles(resource_type=\"documentation\")\n\n# For plugin discovery\nplugin_discovery = ResourceDiscovery(\"*.plugins\")\nplugins = plugin_discovery.discover_bundles(resource_type=\"extension\")\n\n# For template discovery  \ntemplate_discovery = ResourceDiscovery(\"*.templates\")\ntemplates = template_discovery.discover_bundles(resource_type=\"jinja2\")\n</code></pre>"},{"location":"archive/historical/future/bundle-discovery-pattern/#benefits","title":"Benefits","text":"<ol> <li>Reusability: Any project needing asset/resource discovery</li> <li>Standardization: Common pattern across provide ecosystem</li> <li>Extensibility: Support for different bundle types and metadata formats</li> <li>Performance: Caching and optimization opportunities</li> </ol>"},{"location":"archive/historical/future/bundle-discovery-pattern/#migration-path","title":"Migration Path","text":"<ol> <li>Extract plating's bundle logic to foundation</li> <li>Update plating to use foundation's discovery module  </li> <li>Provide backward compatibility adapters</li> <li>Document migration guide for other projects</li> </ol>"},{"location":"archive/historical/future/bundle-discovery-pattern/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Support multiple asset directories per bundle</li> <li>Flexible metadata loading (YAML, JSON, TOML)</li> <li>Plugin hooks for custom bundle types</li> <li>Caching layer for performance</li> <li>Async discovery support for large package sets</li> </ul>"},{"location":"archive/historical/future/template-processing-pipeline/","title":"Template Processing Pipeline for Foundation","text":"<p>Status: \ud83d\udca1 Proposal Date: 2025-01-25 Implementation: Not yet started Discussion: This is a forward-looking proposal for extracting plating's template engine into foundation</p>"},{"location":"archive/historical/future/template-processing-pipeline/#overview","title":"Overview","text":"<p>Plating's async template rendering with Jinja2 integration and partials support could become a general-purpose template processing module in foundation.</p>"},{"location":"archive/historical/future/template-processing-pipeline/#proposed-foundation-module-providefoundationtemplates","title":"Proposed Foundation Module: <code>provide.foundation.templates</code>","text":""},{"location":"archive/historical/future/template-processing-pipeline/#core-classes","title":"Core Classes","text":"<pre><code>from typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass TemplateLoader(Protocol):\n    \"\"\"Protocol for template loading strategies.\"\"\"\n\n    async def load_template(self, name: str) -&gt; str:\n        \"\"\"Load template content by name.\"\"\"\n        ...\n\n    async def load_partials(self, template_name: str) -&gt; dict[str, str]:\n        \"\"\"Load partial templates related to a template.\"\"\"\n        ...\n\nclass AsyncTemplateEngine:\n    \"\"\"Async template processing with partials support.\"\"\"\n\n    def __init__(\n        self,\n        loader: TemplateLoader,\n        engine_type: str = \"jinja2\",\n        global_context: dict[str, Any] = None\n    ):\n        self.loader = loader\n        self.engine_type = engine_type\n        self.global_context = global_context or {}\n        self._setup_engine()\n\n    async def render(\n        self, \n        template_name: str, \n        context: dict[str, Any],\n        partials: dict[str, str] = None\n    ) -&gt; str:\n        \"\"\"Render template with context and partials.\"\"\"\n        # Async implementation with metrics tracking\n\n    async def render_batch(\n        self, \n        templates: list[tuple[str, dict[str, Any]]]\n    ) -&gt; list[str]:\n        \"\"\"Render multiple templates in parallel.\"\"\"\n        # Parallel processing with rate limiting\n\n    def add_global_function(self, name: str, func: callable):\n        \"\"\"Add global template function.\"\"\"\n        # Similar to plating's template function registration\n\nclass FileTemplateLoader:\n    \"\"\"Load templates from filesystem.\"\"\"\n\n    def __init__(self, template_dirs: list[Path]):\n        self.template_dirs = template_dirs\n\n    async def load_template(self, name: str) -&gt; str:\n        # Find and load template file\n\n    async def load_partials(self, template_name: str) -&gt; dict[str, str]:\n        # Load related partial templates\n\nclass BundleTemplateLoader:\n    \"\"\"Load templates from resource bundles.\"\"\"\n\n    def __init__(self, bundles: list[ResourceBundle]):\n        self.bundles = bundles\n\n    async def load_template(self, name: str) -&gt; str:\n        # Load template from appropriate bundle\n\nclass CachingTemplateLoader:\n    \"\"\"Wrapper that adds caching to any loader.\"\"\"\n\n    def __init__(self, loader: TemplateLoader, cache_ttl: int = 300):\n        self.loader = loader\n        self.cache_ttl = cache_ttl\n        self._cache = {}\n</code></pre>"},{"location":"archive/historical/future/template-processing-pipeline/#usage-examples","title":"Usage Examples","text":"<pre><code># Basic usage\nfrom provide.foundation.templates import AsyncTemplateEngine, FileTemplateLoader\n\nloader = FileTemplateLoader([Path(\"templates\"), Path(\"partials\")])\nengine = AsyncTemplateEngine(loader)\n\n# Add custom functions\nengine.add_global_function(\"format_date\", lambda d: d.strftime(\"%Y-%m-%d\"))\n\n# Render single template\nresult = await engine.render(\"documentation.md\", {\n    \"title\": \"API Docs\",\n    \"components\": components_data\n})\n\n# Render multiple templates in parallel\nresults = await engine.render_batch([\n    (\"api.md\", api_context),\n    (\"guide.md\", guide_context),\n    (\"reference.md\", ref_context)\n])\n\n# Using with resource bundles  \nfrom provide.foundation.discovery import ResourceDiscovery\n\ndiscovery = ResourceDiscovery(\"*.templates\")\nbundles = discovery.discover_bundles(resource_type=\"documentation\")\n\nbundle_loader = BundleTemplateLoader(bundles)\ncached_loader = CachingTemplateLoader(bundle_loader, cache_ttl=600)\nengine = AsyncTemplateEngine(cached_loader)\n</code></pre>"},{"location":"archive/historical/future/template-processing-pipeline/#features","title":"Features","text":"<ol> <li>Async-First: Built for high-performance parallel rendering</li> <li>Pluggable Loaders: Multiple template source strategies</li> <li>Caching Layer: Template compilation and content caching</li> <li>Metrics Integration: Built-in performance monitoring</li> <li>Multiple Engines: Support for Jinja2, Mako, etc.</li> <li>Partial Support: Modular template composition</li> <li>Global Functions: Extensible template function registry</li> <li>Rate Limiting: Controlled resource usage in batch operations</li> </ol>"},{"location":"archive/historical/future/template-processing-pipeline/#advanced-features","title":"Advanced Features","text":"<pre><code># With resilience patterns\nfrom provide.foundation.resilience import RetryExecutor, CircuitBreaker\n\nengine = AsyncTemplateEngine(\n    loader=loader,\n    retry_executor=RetryExecutor(...),\n    circuit_breaker=CircuitBreaker(...)\n)\n\n# With streaming for large templates\nasync for chunk in engine.render_stream(\"large_template.html\", context):\n    # Process template chunks as they're rendered\n\n# With template inheritance and includes\nengine.add_template_path(\"base_templates/\")\nresult = await engine.render(\"child_template.html\", context)\n</code></pre>"},{"location":"archive/historical/future/template-processing-pipeline/#benefits","title":"Benefits","text":"<ol> <li>Performance: Async processing enables high throughput</li> <li>Flexibility: Multiple loader strategies for different use cases  </li> <li>Reliability: Built-in resilience and caching</li> <li>Observability: Metrics and monitoring integration</li> <li>Reusability: Generic enough for many template use cases</li> </ol>"},{"location":"archive/historical/future/template-processing-pipeline/#migration-path","title":"Migration Path","text":"<ol> <li>Extract plating's template logic to foundation</li> <li>Add async capabilities and loader abstractions</li> <li>Update plating to use foundation's template engine</li> <li>Provide compatibility layer for existing template code</li> <li>Add support for additional template engines</li> </ol>"}]}