{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Plating Documentation","text":"<p>Welcome to Plating - Documentation and code generation templates for consistent project scaffolding and documentation automation.</p>"},{"location":"#features","title":"Features","text":"<p>Plating provides:</p> <ul> <li>Template Engine: Powerful templating system for code and documentation generation</li> <li>Project Scaffolding: Automated project structure creation</li> <li>Documentation Generation: Consistent documentation patterns across projects</li> <li>Code Templates: Reusable code templates and patterns</li> <li>Multi-Language Support: Templates for Python, Go, TypeScript, and more</li> <li>Integration Tools: CI/CD and development workflow templates</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install plating\n// Installing plating...\nSuccessfully installed plating\n\n$ plating --version\nplating, version 0.1.0\n</code></pre>"},{"location":"#scaffold-a-new-component","title":"Scaffold a New Component","text":"<pre><code>$ plating scaffold --component-type resource --name example_resource\n// Creating .plating directory structure...\n\u2713 Created example_resource.plating/\n\u2713 Created docs/ directory\n\u2713 Created examples/ directory\n// Resource scaffold complete!\n\n$ ls example_resource.plating/\ndocs/  examples/  resource.md.j2\n</code></pre>"},{"location":"#generate-documentation","title":"Generate Documentation","text":"<pre><code>$ plating render --output-dir docs/\n// Discovering plating bundles...\nFound 3 components\n// Rendering documentation...\n---&gt; 100%\n\u2713 Generated docs/resources/example_resource.md\n\u2713 Generated docs/data-sources/example_data.md\n\u2713 Generated docs/functions/example_function.md\n\nDocumentation generated successfully!\n</code></pre>"},{"location":"#python-api-usage","title":"Python API Usage","text":"<pre><code>from plating import Template, Generator\n\n# Load a template\ntemplate = Template.load(\"python-package\")\n\n# Generate project structure\ngenerator = Generator(template)\ngenerator.create_project(\"my-new-project\", {\n    \"package_name\": \"my_package\",\n    \"author\": \"Your Name\"\n})\n</code></pre>"},{"location":"#api-reference","title":"API Reference","text":"<p>For complete API documentation, see the API Reference.</p>"},{"location":"#template-types","title":"Template Types","text":"<ul> <li>Project Templates: Complete project scaffolding</li> <li>Documentation Templates: README, API docs, and guides</li> <li>Code Templates: Classes, functions, and modules</li> <li>Configuration Templates: CI/CD, build, and deployment configs</li> </ul>"},{"location":"04-authoring-garnish-bundles/","title":"Macro Rendering Error","text":"<p>File: <code>04-authoring-garnish-bundles.md</code></p> <p>UndefinedError: 'example' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 699, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 33, in top-level template code\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/utils.py\", line 92, in from_obj\n    if hasattr(obj, \"jinja_pass_arg\"):\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'example' is undefined\n</code></pre>"},{"location":"API/","title":"Macro Rendering Error","text":"<p>File: <code>API.md</code></p> <p>UndefinedError: 'schema' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 699, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 124, in top-level template code\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/utils.py\", line 92, in from_obj\n    if hasattr(obj, \"jinja_pass_arg\"):\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'schema' is undefined\n</code></pre>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Initial implementation of the <code>soup</code> CLI with lazy-loading commands.</li> <li>Core modules for <code>cty</code>, <code>hcl</code>, <code>wire</code>, <code>rpc</code>, <code>harness</code>, and <code>testing</code>.</li> <li>Go harnesses for CTY, HCL, Wire, and RPC (K/V store).</li> <li>Pytest-based conformance testing framework.</li> <li><code>.plating</code> documentation system with <code>scaffold</code> and <code>render</code> commands.</li> <li><code>workenv</code> tool management system for managing TF, Tofu, Go, etc.</li> <li><code>stir</code> command for parallel Terraform integration testing.</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Refactored <code>pyvider-cty</code> dependencies and stabilized APIs.</li> <li>Consolidated test suites under the <code>soup test</code> command.</li> <li>Standardized on <code>soup.toml</code> for all configuration.</li> </ul>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Addressed binary mismatches between Python and Go encoders for CTY and Wire protocols.</li> </ul>"},{"location":"CHANGELOG/#known-issues","title":"Known Issues","text":"<ul> <li>The <code>pyvider-builder</code> project requires a significant refactoring to consolidate Go and Python logic.</li> <li>The conformance test suite structure needs to be reorganized according to the architectural plan to better separate unit, integration, and other test types.</li> </ul>"},{"location":"CONFIGURATION/","title":"TofuSoup Configuration (<code>soup.toml</code>)","text":"<p>TofuSoup uses a TOML file named <code>soup.toml</code> for configuration. This file allows users to customize default behaviors for various commands, harness settings, and test execution parameters.</p>"},{"location":"CONFIGURATION/#location","title":"Location","text":"<p>TofuSoup searches for <code>soup.toml</code> in the following order: 1.  Path specified by the global <code>--config-file &lt;path&gt;</code> CLI option. 2.  <code>./soup.toml</code> (in the current working directory). 3.  <code>&lt;project_root&gt;/soup/soup.toml</code> (recommended default location).</p> <p>If no configuration file is found, TofuSoup operates with built-in defaults.</p>"},{"location":"CONFIGURATION/#precedence","title":"Precedence","text":"<p>For settings that can be defined in multiple places, the following order of precedence applies (highest to lowest): 1.  Command-line arguments. 2.  Environment variables (e.g., <code>TOFUSOUP_LOG_LEVEL</code>). 3.  Settings in <code>soup.toml</code>. 4.  Hardcoded application defaults.</p>"},{"location":"CONFIGURATION/#top-level-tables","title":"Top-Level Tables","text":""},{"location":"CONFIGURATION/#global_settings","title":"<code>[global_settings]</code>","text":"<p>Settings that apply across the TofuSoup application.</p> <ul> <li><code>default_python_log_level</code> (String): Sets the default logging level for TofuSoup's own Python-based logging. Valid values: \"TRACE\", \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\".</li> <li><code>default_harness_log_level</code> (String): A general default log level for external Go harnesses. Valid values for Go harnesses: \"TRACE\", \"DEBUG\", \"INFO\", \"WARN\", \"ERROR\".</li> </ul>"},{"location":"CONFIGURATION/#harness_defaultslanguage","title":"<code>[harness_defaults.&lt;language&gt;]</code>","text":"<p>Provides default settings for all harnesses of a specific language (e.g., <code>[harness_defaults.go]</code>).</p> <ul> <li><code>build_flags</code> (Array of Strings): Default flags passed to <code>go build</code>.</li> <li><code>common_env_vars</code> (Table): Environment variables to set for all Go harness operations.</li> <li><code>default_log_level</code> (String): Default log level specifically for Go harnesses.</li> <li><code>timeout_seconds</code> (Integer): Default timeout for running Go harness commands.</li> </ul>"},{"location":"CONFIGURATION/#harnesslanguagecomponent_id","title":"<code>[harness.&lt;language&gt;.\"&lt;component_id&gt;\"]</code>","text":"<p>Specific settings for an individual harness, overriding language defaults. Example: <code>[harness.go.cty]</code>.</p> <ul> <li><code>build_flags</code>, <code>custom_env_vars</code>, <code>log_level</code>, <code>timeout_seconds</code>.</li> </ul>"},{"location":"CONFIGURATION/#command_optionscommand_groupcommand_name","title":"<code>[command_options.\"&lt;command_group&gt;.&lt;command_name&gt;\"]</code>","text":"<p>Provides default values for specific CLI command options.</p> <p>Example: <pre><code>[command_options.\"hcl.convert\"]\ndefault_output_format = \"json\"\n</code></pre></p>"},{"location":"CONFIGURATION/#test_suite_defaults","title":"<code>[test_suite_defaults]</code>","text":"<p>Default settings applicable to all test suites run via <code>soup test</code>.</p> <ul> <li><code>env_vars</code> (Table): Environment variables to set for all test runs.</li> <li><code>extra_pytest_args</code> (Array of Strings): Additional arguments always passed to <code>pytest</code>.</li> <li><code>skip_tests</code> (Array of Strings): Test items to skip.</li> </ul>"},{"location":"CONFIGURATION/#test_suitesuite_name","title":"<code>[test_suite.&lt;suite_name&gt;]</code>","text":"<p>Specific settings for a named test suite (e.g., <code>[test_suite.rpc]</code>), overriding defaults.</p> <ul> <li><code>env_vars</code>, <code>extra_pytest_args</code>, <code>skip_tests</code>.</li> </ul>"},{"location":"CONFIGURATION/#workenv","title":"<code>[workenv]</code>","text":"<p>Configuration for tool management, powered by wrkenv. When configured in soup.toml, these settings are injected into wrkenv, making wrkenv.toml optional.</p> <ul> <li><code>terraform_flavor</code> (String): Default terraform flavor - \"terraform\" or \"opentofu\"</li> <li><code>tools</code> (Table): Tool versions to use (e.g., <code>terraform = \"1.5.7\"</code>)</li> <li><code>settings</code> (Table): Various settings like <code>verify_checksums</code> and <code>cache_downloads</code></li> </ul>"},{"location":"CONFIGURATION/#workenvmatrix","title":"<code>[workenv.matrix]</code>","text":"<p>Configuration for matrix testing with <code>soup stir --matrix</code>.</p> <ul> <li><code>versions</code> (Table): Additional versions to test for each tool</li> <li><code>parallel_jobs</code> (Integer): Number of parallel test jobs (default: 4)</li> <li><code>timeout_minutes</code> (Integer): Timeout for each test run (default: 30)</li> </ul> <p>Example: <pre><code>[workenv]\nterraform_flavor = \"opentofu\"\n\n[workenv.tools]\nterraform = \"1.8.5\"\ntofu = \"1.10.5\"\n\n[workenv.settings]\nverify_checksums = true\ncache_downloads = true\n\n[workenv.matrix]\nparallel_jobs = 8\ntimeout_minutes = 45\n\n[workenv.matrix.versions]\nterraform = [\"1.5.7\", \"1.6.0\", \"1.6.1\"]\ntofu = [\"1.6.2\", \"1.7.0\", \"1.8.0\"]\n</code></pre></p> <p>Note: You can alternatively configure wrkenv using a <code>wrkenv.toml</code> file. Settings in soup.toml take precedence over wrkenv.toml.</p>"},{"location":"STATUS/","title":"TofuSoup Project Status Update","text":"<p>Date: August 7, 2025</p>"},{"location":"STATUS/#1-project-goal","title":"1. Project Goal","text":"<p>The overarching goal of the <code>tofusoup</code> project is to provide a comprehensive, cross-language conformance testing suite and utility toolkit for ensuring compatibility and correctness across various implementations of OpenTofu-related technologies, including CTY, HCL, RPC mechanisms, and the Terraform Wire Protocol (tfwire). The <code>soup-go</code> executable is intended to be a polyglot harness, mirroring core functionalities of the Python <code>soup</code> CLI for CTY, HCL, RPC, and Wire, enabling cross-language interoperability testing.</p>"},{"location":"STATUS/#2-current-state-issues-encountered","title":"2. Current State &amp; Issues Encountered","text":"<p>Initial attempts to run <code>pytest</code> and <code>soup test all</code> within the <code>tofusoup</code> directory revealed several critical issues, primarily related to the Go harness (<code>soup-go</code>) build process and its CLI functionality.</p> <p>Key Issues Identified:</p> <ul> <li> <p>Go Harness Build Failures (<code>soup-go</code>):</p> <ul> <li><code>protoc-gen-go: program not found</code>: This error persistently occurred during the <code>go generate</code> step, indicating that the <code>protoc</code> plugins (<code>protoc-gen-go</code> and <code>protoc-gen-go-grpc</code>) were not found in the <code>PATH</code> environment variable when the <code>go generate</code> subprocess was invoked.</li> <li><code>package tofusoup/harness/go/soup-go/proto is not in std</code>: This error, appearing during <code>go build</code>, suggests that the Go compiler is failing to recognize the locally generated <code>proto</code> package as part of the <code>soup-go</code> module, instead looking for it in the standard library. This is a fundamental module resolution problem.</li> <li><code>go.mod</code> dependency conflicts: The <code>go.mod</code> file contained a <code>require</code> for <code>github.com/hashicorp/go-cty</code> which conflicted with the intended <code>github.com/zclconf/go-cty</code>.</li> </ul> </li> <li> <p><code>soup-go cty</code> Command Limitations:</p> <ul> <li><code>unknown flag: --input-format</code> / <code>--output-format</code>: The <code>soup-go cty convert</code> command, as implemented, did not recognize the <code>--input-format</code> and <code>--output-format</code> flags, indicating a mismatch between the Python test expectations and the Go implementation.</li> <li><code>invalid primitive type name \"list(string)\"</code>: The <code>soup-go cty validate-value</code> command failed to correctly parse and validate complex CTY type strings (e.g., <code>list(string)</code>), suggesting it only supported primitive types.</li> </ul> </li> <li> <p>Python CTY Serialization:</p> <ul> <li><code>AttributeError: 'CtyValue' object has no attribute 'to_legacy_dict'</code>: The Python tests were attempting to use a deprecated method for CTY value serialization.</li> <li><code>TypeError: cty_to_msgpack() missing 1 required positional argument: 'schema'</code>: The <code>cty_to_msgpack</code> function was being called without its required <code>schema</code> argument.</li> <li><code>TypeError: Object of type bytes is not JSON serializable</code>: When attempting to serialize <code>CtyValue</code> objects (specifically <code>UnknownValue</code> and <code>CtyDynamic</code>) to JSON, the internal <code>bytes</code> representation caused JSON serialization errors.</li> </ul> </li> </ul>"},{"location":"STATUS/#3-actions-taken","title":"3. Actions Taken","text":"<p>The following actions have been taken to address the identified issues:</p> <ul> <li> <p>Python Test Fixes (<code>conformance/cty/souptest_cty_interop.py</code>):</p> <ul> <li>Updated <code>cty_to_msgpack</code> calls with <code>schema</code> argument.</li> <li>Updated <code>validate-value</code> type string to use <code>json.dumps(encode_cty_type_to_wire_json(cty_value.type))</code>.</li> <li>Reverted to <code>cty_to_native</code> for JSON serialization, acknowledging its limitations with <code>bytes</code> output.</li> <li>Introduced <code>_cty_value_to_json_compatible_value</code> helper function to handle JSON serialization of <code>CtyValue</code> objects, including <code>UnknownValue</code> and <code>CtyDynamic</code> types.</li> </ul> </li> <li> <p>Go Harness Build Environment Fixes (<code>tofusoup/src/tofusoup/harness/go/build.py</code>):</p> <ul> <li>Ensured <code>$(go env GOPATH)/bin</code> is added to the <code>PATH</code> environment variable for subprocesses in <code>build.py</code> to help <code>protoc</code> find its plugins.</li> <li>Set <code>force_rebuild=True</code> in the <code>go_harness_executable</code> pytest fixture to ensure <code>soup-go</code> is always rebuilt with the latest changes.</li> </ul> </li> <li> <p>Go Harness <code>cty</code> Command Implementation (<code>tofusoup/src/tofusoup/harness/go/soup-go/cmd/cty.go</code>):</p> <ul> <li>Implemented the <code>cty convert</code> Cobra command with support for <code>--input-format</code> and <code>--output-format</code> flags (JSON and MessagePack).</li> <li>Corrected the <code>validate-value</code> command to remove the erroneous <code>fmt.Sprintf(\"%q\", typeString)</code> quoting.</li> </ul> </li> <li> <p>Go Module and Protobuf Generation Fixes:</p> <ul> <li>Corrected <code>ctyjson</code> and <code>ctymsgpack</code> import paths in <code>cmd/cty.go</code> to <code>github.com/zclconf/go-cty/cty/json</code> and <code>github.com/zclconf/go-cty/cty/msgpack</code>.</li> <li>Removed the conflicting <code>github.com/hashicorp/go-cty</code> dependency from <code>go.mod</code>.</li> <li>Manually created <code>tofusoup/src/tofusoup/harness/go/soup-go/proto</code> and copied <code>kv.proto</code> into it.</li> <li>Manually ran <code>protoc</code> with explicit plugin paths (<code>--plugin=protoc-gen-go=...</code>, <code>--plugin=protoc-gen-go-grpc=...</code>) to generate the Go protobuf code.</li> <li>Removed the <code>go:generate</code> directive from <code>plugin.go</code> (as manual generation is currently being used).</li> <li>Performed an aggressive clean of Go module cache and re-initialized the module.</li> <li>Attempted to resolve module path issues by moving <code>soup-go</code> directory contents to a temporary location and back.</li> </ul> </li> </ul>"},{"location":"STATUS/#4-current-status","title":"4. Current Status","text":"<p>MAJOR PROGRESS: The Go harness build issues have been resolved and comprehensive RPC matrix testing infrastructure is now operational.</p> <p>Key Achievements:</p> <ul> <li> <p>\u2705 Go Harness Build Fixed: The <code>soup-go</code> binary now builds successfully after fixing critical path and build configuration issues:</p> <ul> <li>Fixed variable scope error in <code>harness/go/build.py:39</code> (harness_source_dir indentation)</li> <li>Corrected source directory path in <code>harness/logic.py:12</code> to point to correct location</li> <li><code>soup test all</code> now runs successfully with improved test results</li> </ul> </li> <li> <p>\u2705 RPC Matrix Testing Infrastructure Complete:</p> <ul> <li>Comprehensive matrix testing framework implemented for all client-server-crypto combinations</li> <li>Python\u2192Go RPC: WORKING (TLS disabled mode confirmed functional)</li> <li>Go\u2192Go RPC: WORKING (CLI verified)</li> <li>Go\u2192Python RPC: CONFIRMED WORKING in Terraform context (user validated)</li> <li>Python\u2192Python RPC: Known plugin handshake timeout issues</li> </ul> </li> <li> <p>\u2705 AutoMTLS Compatibility Testing:</p> <ul> <li>Documented asymmetric autoMTLS behavior: Go can connect to Python, but Python cannot connect to Go</li> <li>SSL/TLS handshake failures identified as implementation bugs in grpcio plugin, not \"expected\" behavior</li> <li>Complete test suite covers RSA 2048/4096 and EC P-256/P-384/P-521 across all combinations</li> </ul> </li> </ul> <p>Current Issues:</p> <ul> <li> <p>SSL/TLS Handshake Failures: Python client experiences \"Invalid certificate verification context\" errors when connecting to Go servers with autoMTLS enabled. This is a bug in the C-based grpcio plugin implementation, not expected behavior.</p> </li> <li> <p>Python Server Plugin Handshake: Python server has timeout issues during plugin protocol negotiation, affecting Python\u2192Python and some Go\u2192Python scenarios.</p> </li> </ul>"},{"location":"STATUS/#5-detailed-checklist-of-remaining-tasks","title":"5. Detailed Checklist of Remaining Tasks","text":"<p>This checklist prioritizes tasks to achieve a fully functional <code>tofusoup</code> conformance suite.</p> <p>P0: RPC Matrix Testing (COMPLETED \u2705) *   [\u2705] Go Harness Build Fixed: Core build issues resolved *   [\u2705] Matrix Testing Infrastructure: Comprehensive test framework implemented *   [\u2705] AutoMTLS Compatibility Verification: All combinations documented</p> <p>P1: SSL/TLS Implementation Bug Fixes *   [\ud83d\udd34] Fix grpcio SSL Handshake Bug: Address \"Invalid certificate verification context\" errors in Python client when connecting to Go servers with autoMTLS *   [\ud83d\udd34] Fix Python Server Plugin Handshake: Resolve timeout issues during plugin protocol negotiation *   [\ud83d\udea7] Certificate Generation Compatibility: Ensure cross-language certificate compatibility between Go's auto-generated certs and Python's grpcio</p> <p>P2: Complete <code>soup-go</code> CTY Functionality *   [\u2705] Verify <code>cty convert</code>: Command structure implemented and functional \u2705 *   [\u2705] Verify <code>cty validate-value</code>: Command structure implemented and functional \u2705 *   [\ud83d\udea7] Cross-language CTY Testing: Verify complex CTY type conversions work correctly between Python and Go</p> <p>P3: Implement Remaining <code>soup-go</code> CLI Commands (As per <code>tofusoup/docs/README.md</code>) *   [\ud83d\udea7] Implement <code>soup-go hcl</code> commands: \ud83d\udcdd     *   [ ] <code>soup-go hcl view</code> \ud83d\udc41\ufe0f     *   [ ] <code>soup-go hcl convert</code> \u2194\ufe0f *   [\ud83d\udea7] Implement <code>soup-go wire</code> commands: \ud83d\udd0c     *   [ ] <code>soup-go wire encode</code> \u27a1\ufe0f     *   [ ] <code>soup-go wire decode</code> \u2b05\ufe0f *   [\u2705] RPC commands implemented: \ud83d\udcde     *   [\u2705] <code>soup-go rpc server-start</code> \ud83d\ude80     *   [\u2705] <code>soup-go rpc kv-get</code> \ud83d\udce5     *   [\u2705] <code>soup-go rpc kv-put</code> \ud83d\udce4</p> <p>P4: Enhanced Matrix Testing *   [\ud83d\udea7] Go Client Plugin Pattern: Implement Go client that uses plugin pattern to connect to Python servers (to match Terraform behavior) *   [\ud83d\udea7] Automated CI Matrix Testing: Set up automated testing of all matrix combinations *   [\ud83d\udea7] Performance Benchmarking: Add performance metrics to matrix testing</p>"},{"location":"STATUS/#6-matrix-testing-results-summary","title":"6. Matrix Testing Results Summary","text":"<p>Complete RPC Matrix Status (20 total combinations):</p> Client Server TLS Mode RSA 2048/4096 EC P-256/P-384 EC P-521 Python Go Disabled \u2705 Working \u2705 Working \u2705 Working Python Go Auto \u274c SSL Bug \u274c SSL Bug \u274c SSL Bug Go Go Disabled \u2705 Working \u2705 Working \u2705 Working Go Go Auto \u2705 Working \u2705 Working \u2705 Working Go Python Disabled \ud83d\udea7 Needs Test \ud83d\udea7 Needs Test \ud83d\udea7 Needs Test Go Python Auto \u2705 Working* \u2705 Working* \ud83d\udea7 Needs Test Python Python Disabled \u274c Handshake \u274c Handshake \u274c Handshake Python Python Auto \u274c Handshake \u274c Handshake \u274c Handshake <p>* Confirmed working in Terraform context (user validated)</p> <p>Key Findings: - Asymmetric AutoMTLS Behavior: Go clients can connect to Python servers with autoMTLS, but Python clients cannot connect to Go servers - SSL Implementation Bug: Python grpcio has certificate verification context issues - Plugin Handshake Issues: Python servers have timeout problems during plugin negotiation - No \"Expected\" Failures: All failures are implementation bugs, not architectural limitations</p>"},{"location":"test-animations/","title":"Terminal Animation Test","text":"<p>This page tests that the Termynal terminal simulator is working correctly.</p>"},{"location":"test-animations/#test-1-basic-commands","title":"Test 1: Basic Commands","text":"<pre><code>$ echo \"Hello World\"\nHello World\n\n$ ls -la\ntotal 24\ndrwxr-xr-x  4 user staff  128 Oct 24 12:00 .\ndrwxr-xr-x 15 user staff  480 Oct 24 11:59 ..\n-rw-r--r--  1 user staff  123 Oct 24 12:00 README.md\n</code></pre>"},{"location":"test-animations/#test-2-with-comments","title":"Test 2: With Comments","text":"<pre><code>$ plating scaffold --component-type resource\n// Creating resource scaffold...\n// Generating templates...\n\u2713 Created example_resource.plating/\n\u2713 Generated docs/resource.md.j2\n\u2713 Generated examples/basic.tf\n\n$ ls example_resource.plating/\ndocs/\nexamples/\n</code></pre>"},{"location":"test-animations/#test-3-with-progress-bar","title":"Test 3: With Progress Bar","text":"<pre><code>$ plating render --output-dir docs/\n// Rendering documentation...\n---&gt; 100%\n\u2713 Rendered 15 files\n\u2713 Documentation complete!\n</code></pre>"},{"location":"test-animations/#test-4-multi-step-process","title":"Test 4: Multi-Step Process","text":"<pre><code>$ uv sync\n// Installing dependencies...\nResolved 24 packages in 1.2s\n\n$ uv run pytest\n// Running test suite...\n======================== 15 passed in 0.82s ========================\n\n$ uv run plating --help\nUsage: plating [OPTIONS] COMMAND [ARGS]...\n\n  Plating documentation generator\n\nOptions:\n  --help  Show this message and exit.\n</code></pre>"},{"location":"test-animations/#verification-checklist","title":"Verification Checklist","text":"<p>If terminal animations are working correctly, you should see:</p> <ul> <li>\u2705 Commands typing out with animation</li> <li>\u2705 Comments showing with \ud83d\udcac emoji</li> <li>\u2705 Progress bars animating from 0% to 100%</li> <li>\u2705 Output appearing instantly after commands</li> <li>\u2705 Restart (\u21bb) and Fast Forward (\u2192) buttons</li> <li>\u2705 Smooth transitions and timing</li> </ul> <p>If you see static code blocks instead, check:</p> <ol> <li>Browser console for JavaScript errors</li> <li>Network tab for 404s on theme files</li> <li>Verify <code>.shared-theme/</code> directory exists in <code>docs/</code></li> <li>Verify <code>mkdocs.yml</code> has correct paths</li> </ol>"},{"location":"api/","title":"Plating API","text":"<p>Auto-generated API documentation for <code>plating</code>.</p> <p>Modern async documentation generation with full foundation integration.</p> <p>A clean, type-safe API for generating high-quality Terraform/OpenTofu provider documentation with foundation patterns.</p> <p>Key Features: - Type-safe async-first API - Full foundation integration (retry, metrics, circuit breakers) - Registry-based component discovery - Integrated markdown validation with configurable rules - Context-aware template rendering with Jinja2 - Support for resources, data sources, functions, and provider docs</p> Example Usage <pre><code>import asyncio\nfrom pathlib import Path\nfrom plating import Plating, ComponentType, PlatingContext\nfrom provide.foundation import pout\n\nasync def main():\n    # Initialize with foundation context\n    context = PlatingContext(\n        provider_name=\"my_provider\",\n        log_level=\"INFO\",\n        no_color=False\n    )\n\n    api = Plating(context)\n\n    # Create missing templates\n    adorn_result = await api.adorn(component_types=[ComponentType.RESOURCE])\n    pout(f\"\u2705 Created {adorn_result.templates_generated} templates\")\n\n    # Generate docs with validation\n    plate_result = await api.plate(\n        Path(\"docs\"),\n        component_types=[ComponentType.RESOURCE],\n        validate_markdown=True,\n        force=True\n    )\n\n    if plate_result.success:\n        pout(f\"\u2705 Generated {len(plate_result.output_files)} files\")\n\n    # Validate existing documentation\n    validation_result = await api.validate()\n    pout(f\"\ud83d\udcca Validation: {validation_result.passed}/{validation_result.total} passed\")\n\n# Run the async main\nasyncio.run(main())\n</code></pre> CLI Usage <pre><code># Create missing templates\nplating adorn --component-type resource --provider-name my_provider\n\n# Generate documentation\nplating plate --output-dir docs --validate\n\n# Validate existing docs\nplating validate --output-dir docs\n\n# Show registry info\nplating info --provider-name my_provider\n</code></pre>"},{"location":"api/#plating-attributes","title":"Attributes","text":""},{"location":"api/#plating.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = get_version('plating', caller_file=__file__)\n</code></pre>"},{"location":"api/#plating.plating_metrics","title":"plating_metrics  <code>module-attribute</code>","text":"<pre><code>plating_metrics = PlatingMetrics()\n</code></pre>"},{"location":"api/#plating.template_engine","title":"template_engine  <code>module-attribute</code>","text":"<pre><code>template_engine = AsyncTemplateEngine()\n</code></pre>"},{"location":"api/#plating.PlatingContext","title":"PlatingContext  <code>module-attribute</code>","text":"<pre><code>PlatingContext = PlatingCLIContext\n</code></pre>"},{"location":"api/#plating.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"Plating\",\n    \"plating\",\n    \"AdornResult\",\n    \"ArgumentInfo\",\n    \"ComponentType\",\n    \"PlateResult\",\n    \"PlatingContext\",\n    \"SchemaInfo\",\n    \"ValidationResult\",\n    \"AsyncTemplateEngine\",\n    \"template_engine\",\n    \"FunctionPlatingBundle\",\n    \"ModularPlatingBundle\",\n    \"ModularPlatingDiscovery\",\n    \"TemplateMetadataExtractor\",\n    \"DocumentationAdorner\",\n    \"DocumentationPlater\",\n    \"PlatingRegistry\",\n    \"get_plating_registry\",\n    \"reset_plating_registry\",\n    \"plating_metrics\",\n    \"with_circuit_breaker\",\n    \"with_metrics\",\n    \"with_retry\",\n    \"with_timing\",\n    \"__version__\",\n]\n</code></pre>"},{"location":"api/#plating-classes","title":"Classes","text":""},{"location":"api/#plating.FunctionPlatingBundle","title":"FunctionPlatingBundle","text":"<p>               Bases: <code>PlatingBundle</code></p> <p>Specialized PlatingBundle for individual function templates.</p>"},{"location":"api/#plating.FunctionPlatingBundle-attributes","title":"Attributes","text":""},{"location":"api/#plating.FunctionPlatingBundle.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.plating_dir","title":"plating_dir  <code>instance-attribute</code>","text":"<pre><code>plating_dir: Path\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.component_type","title":"component_type  <code>instance-attribute</code>","text":"<pre><code>component_type: str\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.docs_dir","title":"docs_dir  <code>property</code>","text":"<pre><code>docs_dir: Path\n</code></pre> <p>Directory containing documentation templates.</p>"},{"location":"api/#plating.FunctionPlatingBundle.examples_dir","title":"examples_dir  <code>property</code>","text":"<pre><code>examples_dir: Path\n</code></pre> <p>Directory containing example files.</p>"},{"location":"api/#plating.FunctionPlatingBundle.fixtures_dir","title":"fixtures_dir  <code>property</code>","text":"<pre><code>fixtures_dir: Path\n</code></pre> <p>Directory containing fixture files.</p>"},{"location":"api/#plating.FunctionPlatingBundle.template_file","title":"template_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_file: Path = field()\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle-functions","title":"Functions","text":""},{"location":"api/#plating.FunctionPlatingBundle.has_main_template","title":"has_main_template","text":"<pre><code>has_main_template() -&gt; bool\n</code></pre> <p>Check if bundle has a main template file.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def has_main_template(self) -&gt; bool:\n    \"\"\"Check if bundle has a main template file.\"\"\"\n    template_file = self.docs_dir / f\"{self.name}.tmpl.md\"\n    pyvider_template = self.docs_dir / f\"pyvider_{self.name}.tmpl.md\"\n    main_template = self.docs_dir / \"main.md.j2\"\n\n    return any(template.exists() for template in [template_file, pyvider_template, main_template])\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.has_examples","title":"has_examples","text":"<pre><code>has_examples() -&gt; bool\n</code></pre> <p>Check if bundle has example files (flat .tf or grouped).</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def has_examples(self) -&gt; bool:\n    \"\"\"Check if bundle has example files (flat .tf or grouped).\"\"\"\n    if not self.examples_dir.exists():\n        return False\n\n    # Check for flat .tf files\n    if any(self.examples_dir.glob(\"*.tf\")):\n        return True\n\n    # Check for grouped examples (subdirectories with main.tf)\n    for subdir in self.examples_dir.iterdir():\n        if subdir.is_dir() and (subdir / \"main.tf\").exists():\n            return True\n\n    return False\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.load_examples","title":"load_examples","text":"<pre><code>load_examples() -&gt; dict[str, str]\n</code></pre> <p>Load all example files - both flat .tf and grouped subdirs.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping example name to content:</p> <code>dict[str, str]</code> <ul> <li>Flat .tf files: key is filename stem (e.g., \"basic.tf\" -&gt; \"basic\")</li> </ul> <code>dict[str, str]</code> <ul> <li>Grouped examples: key is subdirectory name (e.g., \"full_stack/main.tf\" -&gt; \"full_stack\")</li> </ul> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_examples(self) -&gt; dict[str, str]:\n    \"\"\"Load all example files - both flat .tf and grouped subdirs.\n\n    Returns:\n        Dictionary mapping example name to content:\n        - Flat .tf files: key is filename stem (e.g., \"basic.tf\" -&gt; \"basic\")\n        - Grouped examples: key is subdirectory name (e.g., \"full_stack/main.tf\" -&gt; \"full_stack\")\n    \"\"\"\n    examples: dict[str, str] = {}\n    if not self.examples_dir.exists():\n        return examples\n\n    # Load flat .tf files (backward compatible)\n    for example_file in self.examples_dir.glob(\"*.tf\"):\n        try:\n            examples[example_file.stem] = example_file.read_text(encoding=\"utf-8\")\n        except Exception:\n            continue\n\n    # Load grouped examples (subdirectories with main.tf)\n    for subdir in self.examples_dir.iterdir():\n        if subdir.is_dir():\n            main_tf = subdir / \"main.tf\"\n            if main_tf.exists():\n                try:\n                    examples[subdir.name] = main_tf.read_text(encoding=\"utf-8\")\n                except Exception:\n                    continue\n\n    return examples\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.load_partials","title":"load_partials","text":"<pre><code>load_partials() -&gt; dict[str, str]\n</code></pre> <p>Load all partial files from docs directory.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_partials(self) -&gt; dict[str, str]:\n    \"\"\"Load all partial files from docs directory.\"\"\"\n    partials: dict[str, str] = {}\n    if not self.docs_dir.exists():\n        return partials\n\n    for partial_file in self.docs_dir.glob(\"_*\"):\n        if partial_file.is_file():\n            try:\n                partials[partial_file.name] = partial_file.read_text(encoding=\"utf-8\")\n            except Exception:\n                continue\n    return partials\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.load_fixtures","title":"load_fixtures","text":"<pre><code>load_fixtures() -&gt; dict[str, str]\n</code></pre> <p>Load all fixture files from fixtures directory.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_fixtures(self) -&gt; dict[str, str]:\n    \"\"\"Load all fixture files from fixtures directory.\"\"\"\n    fixtures: dict[str, str] = {}\n    if not self.fixtures_dir.exists():\n        return fixtures\n\n    for fixture_file in self.fixtures_dir.rglob(\"*\"):\n        if fixture_file.is_file():\n            try:\n                rel_path = fixture_file.relative_to(self.fixtures_dir)\n                fixtures[str(rel_path)] = fixture_file.read_text(encoding=\"utf-8\")\n            except Exception:\n                continue\n    return fixtures\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.get_example_groups","title":"get_example_groups","text":"<pre><code>get_example_groups() -&gt; list[str]\n</code></pre> <p>Get names of example groups (subdirectories with main.tf).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of group names (subdirectory names)</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def get_example_groups(self) -&gt; list[str]:\n    \"\"\"Get names of example groups (subdirectories with main.tf).\n\n    Returns:\n        List of group names (subdirectory names)\n    \"\"\"\n    if not self.examples_dir.exists():\n        return []\n\n    group_names = []\n    for subdir in self.examples_dir.iterdir():\n        if subdir.is_dir() and (subdir / \"main.tf\").exists():\n            group_names.append(subdir.name)\n\n    return group_names\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.load_group_fixtures","title":"load_group_fixtures","text":"<pre><code>load_group_fixtures(group_name: str) -&gt; dict[str, Path]\n</code></pre> <p>Load fixture files from a specific example group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name of the example group</p> required <p>Returns:</p> Type Description <code>dict[str, Path]</code> <p>Dictionary mapping relative path to source Path object</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_group_fixtures(self, group_name: str) -&gt; dict[str, Path]:\n    \"\"\"Load fixture files from a specific example group.\n\n    Args:\n        group_name: Name of the example group\n\n    Returns:\n        Dictionary mapping relative path to source Path object\n    \"\"\"\n    group_fixtures_dir = self.examples_dir / group_name / \"fixtures\"\n    if not group_fixtures_dir.exists():\n        return {}\n\n    fixtures = {}\n    for file_path in group_fixtures_dir.rglob(\"*\"):\n        if file_path.is_file():\n            rel_path = file_path.relative_to(group_fixtures_dir)\n            fixtures[str(rel_path)] = file_path\n\n    return fixtures\n</code></pre>"},{"location":"api/#plating.FunctionPlatingBundle.load_main_template","title":"load_main_template","text":"<pre><code>load_main_template() -&gt; str | None\n</code></pre> <p>Load the specific template file for this function.</p> Source code in <code>src/plating/bundles/function.py</code> <pre><code>def load_main_template(self) -&gt; str | None:\n    \"\"\"Load the specific template file for this function.\"\"\"\n    try:\n        return self.template_file.read_text(encoding=\"utf-8\")\n    except Exception:\n        return None\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle","title":"ModularPlatingBundle","text":"<p>Represents a single .plating bundle with its assets.</p>"},{"location":"api/#plating.ModularPlatingBundle-attributes","title":"Attributes","text":""},{"location":"api/#plating.ModularPlatingBundle.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.plating_dir","title":"plating_dir  <code>instance-attribute</code>","text":"<pre><code>plating_dir: Path\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.component_type","title":"component_type  <code>instance-attribute</code>","text":"<pre><code>component_type: str\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.docs_dir","title":"docs_dir  <code>property</code>","text":"<pre><code>docs_dir: Path\n</code></pre> <p>Directory containing documentation templates.</p>"},{"location":"api/#plating.ModularPlatingBundle.examples_dir","title":"examples_dir  <code>property</code>","text":"<pre><code>examples_dir: Path\n</code></pre> <p>Directory containing example files.</p>"},{"location":"api/#plating.ModularPlatingBundle.fixtures_dir","title":"fixtures_dir  <code>property</code>","text":"<pre><code>fixtures_dir: Path\n</code></pre> <p>Directory containing fixture files.</p>"},{"location":"api/#plating.ModularPlatingBundle-functions","title":"Functions","text":""},{"location":"api/#plating.ModularPlatingBundle.has_main_template","title":"has_main_template","text":"<pre><code>has_main_template() -&gt; bool\n</code></pre> <p>Check if bundle has a main template file.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def has_main_template(self) -&gt; bool:\n    \"\"\"Check if bundle has a main template file.\"\"\"\n    template_file = self.docs_dir / f\"{self.name}.tmpl.md\"\n    pyvider_template = self.docs_dir / f\"pyvider_{self.name}.tmpl.md\"\n    main_template = self.docs_dir / \"main.md.j2\"\n\n    return any(template.exists() for template in [template_file, pyvider_template, main_template])\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.has_examples","title":"has_examples","text":"<pre><code>has_examples() -&gt; bool\n</code></pre> <p>Check if bundle has example files (flat .tf or grouped).</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def has_examples(self) -&gt; bool:\n    \"\"\"Check if bundle has example files (flat .tf or grouped).\"\"\"\n    if not self.examples_dir.exists():\n        return False\n\n    # Check for flat .tf files\n    if any(self.examples_dir.glob(\"*.tf\")):\n        return True\n\n    # Check for grouped examples (subdirectories with main.tf)\n    for subdir in self.examples_dir.iterdir():\n        if subdir.is_dir() and (subdir / \"main.tf\").exists():\n            return True\n\n    return False\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.load_main_template","title":"load_main_template","text":"<pre><code>load_main_template() -&gt; str | None\n</code></pre> <p>Load the main template file for this component.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_main_template(self) -&gt; str | None:\n    \"\"\"Load the main template file for this component.\"\"\"\n    template_file = self.docs_dir / f\"{self.name}.tmpl.md\"\n    pyvider_template = self.docs_dir / f\"pyvider_{self.name}.tmpl.md\"\n    main_template = self.docs_dir / \"main.md.j2\"\n\n    # First, try component-specific templates\n    for template_path in [template_file, pyvider_template]:\n        if template_path.exists():\n            try:\n                return template_path.read_text(encoding=\"utf-8\")\n            except Exception:\n                return None\n\n    # Only use main.md.j2 if it's the only component in this bundle directory\n    # Check if this bundle contains multiple components by looking for other .tmpl.md files\n    if main_template.exists():\n        component_templates = list(self.docs_dir.glob(\"*.tmpl.md\"))\n        if len(component_templates) &lt;= 1:  # Only this component or no specific templates\n            try:\n                return main_template.read_text(encoding=\"utf-8\")\n            except Exception:\n                return None\n\n    return None\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.load_examples","title":"load_examples","text":"<pre><code>load_examples() -&gt; dict[str, str]\n</code></pre> <p>Load all example files - both flat .tf and grouped subdirs.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping example name to content:</p> <code>dict[str, str]</code> <ul> <li>Flat .tf files: key is filename stem (e.g., \"basic.tf\" -&gt; \"basic\")</li> </ul> <code>dict[str, str]</code> <ul> <li>Grouped examples: key is subdirectory name (e.g., \"full_stack/main.tf\" -&gt; \"full_stack\")</li> </ul> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_examples(self) -&gt; dict[str, str]:\n    \"\"\"Load all example files - both flat .tf and grouped subdirs.\n\n    Returns:\n        Dictionary mapping example name to content:\n        - Flat .tf files: key is filename stem (e.g., \"basic.tf\" -&gt; \"basic\")\n        - Grouped examples: key is subdirectory name (e.g., \"full_stack/main.tf\" -&gt; \"full_stack\")\n    \"\"\"\n    examples: dict[str, str] = {}\n    if not self.examples_dir.exists():\n        return examples\n\n    # Load flat .tf files (backward compatible)\n    for example_file in self.examples_dir.glob(\"*.tf\"):\n        try:\n            examples[example_file.stem] = example_file.read_text(encoding=\"utf-8\")\n        except Exception:\n            continue\n\n    # Load grouped examples (subdirectories with main.tf)\n    for subdir in self.examples_dir.iterdir():\n        if subdir.is_dir():\n            main_tf = subdir / \"main.tf\"\n            if main_tf.exists():\n                try:\n                    examples[subdir.name] = main_tf.read_text(encoding=\"utf-8\")\n                except Exception:\n                    continue\n\n    return examples\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.load_partials","title":"load_partials","text":"<pre><code>load_partials() -&gt; dict[str, str]\n</code></pre> <p>Load all partial files from docs directory.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_partials(self) -&gt; dict[str, str]:\n    \"\"\"Load all partial files from docs directory.\"\"\"\n    partials: dict[str, str] = {}\n    if not self.docs_dir.exists():\n        return partials\n\n    for partial_file in self.docs_dir.glob(\"_*\"):\n        if partial_file.is_file():\n            try:\n                partials[partial_file.name] = partial_file.read_text(encoding=\"utf-8\")\n            except Exception:\n                continue\n    return partials\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.load_fixtures","title":"load_fixtures","text":"<pre><code>load_fixtures() -&gt; dict[str, str]\n</code></pre> <p>Load all fixture files from fixtures directory.</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_fixtures(self) -&gt; dict[str, str]:\n    \"\"\"Load all fixture files from fixtures directory.\"\"\"\n    fixtures: dict[str, str] = {}\n    if not self.fixtures_dir.exists():\n        return fixtures\n\n    for fixture_file in self.fixtures_dir.rglob(\"*\"):\n        if fixture_file.is_file():\n            try:\n                rel_path = fixture_file.relative_to(self.fixtures_dir)\n                fixtures[str(rel_path)] = fixture_file.read_text(encoding=\"utf-8\")\n            except Exception:\n                continue\n    return fixtures\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.get_example_groups","title":"get_example_groups","text":"<pre><code>get_example_groups() -&gt; list[str]\n</code></pre> <p>Get names of example groups (subdirectories with main.tf).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of group names (subdirectory names)</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def get_example_groups(self) -&gt; list[str]:\n    \"\"\"Get names of example groups (subdirectories with main.tf).\n\n    Returns:\n        List of group names (subdirectory names)\n    \"\"\"\n    if not self.examples_dir.exists():\n        return []\n\n    group_names = []\n    for subdir in self.examples_dir.iterdir():\n        if subdir.is_dir() and (subdir / \"main.tf\").exists():\n            group_names.append(subdir.name)\n\n    return group_names\n</code></pre>"},{"location":"api/#plating.ModularPlatingBundle.load_group_fixtures","title":"load_group_fixtures","text":"<pre><code>load_group_fixtures(group_name: str) -&gt; dict[str, Path]\n</code></pre> <p>Load fixture files from a specific example group.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Name of the example group</p> required <p>Returns:</p> Type Description <code>dict[str, Path]</code> <p>Dictionary mapping relative path to source Path object</p> Source code in <code>src/plating/bundles/base.py</code> <pre><code>def load_group_fixtures(self, group_name: str) -&gt; dict[str, Path]:\n    \"\"\"Load fixture files from a specific example group.\n\n    Args:\n        group_name: Name of the example group\n\n    Returns:\n        Dictionary mapping relative path to source Path object\n    \"\"\"\n    group_fixtures_dir = self.examples_dir / group_name / \"fixtures\"\n    if not group_fixtures_dir.exists():\n        return {}\n\n    fixtures = {}\n    for file_path in group_fixtures_dir.rglob(\"*\"):\n        if file_path.is_file():\n            rel_path = file_path.relative_to(group_fixtures_dir)\n            fixtures[str(rel_path)] = file_path\n\n    return fixtures\n</code></pre>"},{"location":"api/#plating.ModularPlatingDiscovery","title":"ModularPlatingDiscovery","text":"<pre><code>ModularPlatingDiscovery(package_name: str | None = None)\n</code></pre> <p>Discovers .plating bundles from installed packages.</p> <p>Initialize discovery.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str | None</code> <p>Specific package to search, or None to search all packages</p> <code>None</code> Source code in <code>src/plating/discovery/finder.py</code> <pre><code>def __init__(self, package_name: str | None = None) -&gt; None:\n    \"\"\"Initialize discovery.\n\n    Args:\n        package_name: Specific package to search, or None to search all packages\n    \"\"\"\n    self.package_name = package_name\n</code></pre>"},{"location":"api/#plating.ModularPlatingDiscovery-attributes","title":"Attributes","text":""},{"location":"api/#plating.ModularPlatingDiscovery.package_name","title":"package_name  <code>instance-attribute</code>","text":"<pre><code>package_name = package_name\n</code></pre>"},{"location":"api/#plating.ModularPlatingDiscovery-functions","title":"Functions","text":""},{"location":"api/#plating.ModularPlatingDiscovery.discover_bundles","title":"discover_bundles","text":"<pre><code>discover_bundles(\n    component_type: str | None = None,\n) -&gt; list[PlatingBundle]\n</code></pre> <p>Discover all .plating bundles from installed package(s).</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <code>str | None</code> <p>Optional filter for specific component type</p> <code>None</code> <p>Returns:</p> Type Description <code>list[PlatingBundle]</code> <p>List of discovered PlatingBundle objects</p> Source code in <code>src/plating/discovery/finder.py</code> <pre><code>def discover_bundles(self, component_type: str | None = None) -&gt; list[PlatingBundle]:\n    \"\"\"Discover all .plating bundles from installed package(s).\n\n    Args:\n        component_type: Optional filter for specific component type\n\n    Returns:\n        List of discovered PlatingBundle objects\n    \"\"\"\n    if self.package_name:\n        # Single package discovery\n        return self._discover_from_package(self.package_name, component_type)\n    else:\n        # Global discovery from all installed packages\n        return self._discover_from_all_packages(component_type)\n</code></pre>"},{"location":"api/#plating.DocumentationAdorner","title":"DocumentationAdorner","text":"<pre><code>DocumentationAdorner()\n</code></pre> <p>Enhances documentation content with metadata and template variables.</p> Source code in <code>src/plating/generation/adorner.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.config = get_config()\n</code></pre>"},{"location":"api/#plating.DocumentationAdorner-attributes","title":"Attributes","text":""},{"location":"api/#plating.DocumentationAdorner.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = get_config()\n</code></pre>"},{"location":"api/#plating.DocumentationAdorner-functions","title":"Functions","text":""},{"location":"api/#plating.DocumentationAdorner.adorn_function_template","title":"adorn_function_template","text":"<pre><code>adorn_function_template(\n    template_content: str,\n    function_name: str,\n    metadata: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Create template context for function documentation.</p> <p>Parameters:</p> Name Type Description Default <code>template_content</code> <code>str</code> <p>Raw template content</p> required <code>function_name</code> <code>str</code> <p>Name of the function</p> required <code>metadata</code> <code>dict[str, Any]</code> <p>Function metadata from extractor</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing all template variables</p> Source code in <code>src/plating/generation/adorner.py</code> <pre><code>def adorn_function_template(\n    self, template_content: str, function_name: str, metadata: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Create template context for function documentation.\n\n    Args:\n        template_content: Raw template content\n        function_name: Name of the function\n        metadata: Function metadata from extractor\n\n    Returns:\n        Dictionary containing all template variables\n    \"\"\"\n\n    # Create example function that templates can call\n    def example(example_name: str) -&gt; str:\n        examples = metadata.get(\"examples\", {})\n        result = examples.get(example_name, self.config.example_placeholder)\n        return str(result)\n\n    return {\n        \"function_name\": function_name,\n        \"template_content\": template_content,\n        \"example\": example,\n        **metadata,\n    }\n</code></pre>"},{"location":"api/#plating.DocumentationAdorner.adorn_resource_template","title":"adorn_resource_template","text":"<pre><code>adorn_resource_template(\n    template_content: str,\n    resource_name: str,\n    metadata: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Create template context for resource documentation.</p> <p>Parameters:</p> Name Type Description Default <code>template_content</code> <code>str</code> <p>Raw template content</p> required <code>resource_name</code> <code>str</code> <p>Name of the resource</p> required <code>metadata</code> <code>dict[str, Any]</code> <p>Resource metadata</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing all template variables</p> Source code in <code>src/plating/generation/adorner.py</code> <pre><code>def adorn_resource_template(\n    self, template_content: str, resource_name: str, metadata: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Create template context for resource documentation.\n\n    Args:\n        template_content: Raw template content\n        resource_name: Name of the resource\n        metadata: Resource metadata\n\n    Returns:\n        Dictionary containing all template variables\n    \"\"\"\n\n    # Create example function that templates can call\n    def example(example_name: str) -&gt; str:\n        examples = metadata.get(\"examples\", {})\n        result = examples.get(example_name, self.config.example_placeholder)\n        return str(result)\n\n    # Create schema function that templates can call\n    def schema() -&gt; str:\n        schema_info = metadata.get(\"schema\", {})\n        if not schema_info:\n            return \"No schema information available.\"\n        # Convert schema to markdown format\n        return str(schema_info)\n\n    return {\n        \"resource_name\": resource_name,\n        \"template_content\": template_content,\n        \"example\": example,\n        \"schema\": schema,\n        **metadata,\n    }\n</code></pre>"},{"location":"api/#plating.DocumentationAdorner.enhance_template_context","title":"enhance_template_context","text":"<pre><code>enhance_template_context(\n    context: dict[str, Any], additional_data: dict[str, Any]\n) -&gt; dict[str, Any]\n</code></pre> <p>Enhance template context with additional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict[str, Any]</code> <p>Base template context</p> required <code>additional_data</code> <code>dict[str, Any]</code> <p>Additional data to merge</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Enhanced template context</p> Source code in <code>src/plating/generation/adorner.py</code> <pre><code>def enhance_template_context(\n    self, context: dict[str, Any], additional_data: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Enhance template context with additional metadata.\n\n    Args:\n        context: Base template context\n        additional_data: Additional data to merge\n\n    Returns:\n        Enhanced template context\n    \"\"\"\n    enhanced = context.copy()\n    enhanced.update(additional_data)\n    return enhanced\n</code></pre>"},{"location":"api/#plating.DocumentationPlater","title":"DocumentationPlater","text":"<pre><code>DocumentationPlater(package_name: str)\n</code></pre> <p>Orchestrates the complete documentation generation process using async rendering.</p> Source code in <code>src/plating/generation/plater.py</code> <pre><code>def __init__(self, package_name: str) -&gt; None:\n    self.package_name = package_name\n    self.discovery = PlatingDiscovery(package_name)\n    self.extractor = TemplateMetadataExtractor()\n    self.adorner = DocumentationAdorner()\n    self.renderer = AsyncTemplateEngine()\n</code></pre>"},{"location":"api/#plating.DocumentationPlater-attributes","title":"Attributes","text":""},{"location":"api/#plating.DocumentationPlater.package_name","title":"package_name  <code>instance-attribute</code>","text":"<pre><code>package_name = package_name\n</code></pre>"},{"location":"api/#plating.DocumentationPlater.discovery","title":"discovery  <code>instance-attribute</code>","text":"<pre><code>discovery = PlatingDiscovery(package_name)\n</code></pre>"},{"location":"api/#plating.DocumentationPlater.extractor","title":"extractor  <code>instance-attribute</code>","text":"<pre><code>extractor = TemplateMetadataExtractor()\n</code></pre>"},{"location":"api/#plating.DocumentationPlater.adorner","title":"adorner  <code>instance-attribute</code>","text":"<pre><code>adorner = DocumentationAdorner()\n</code></pre>"},{"location":"api/#plating.DocumentationPlater.renderer","title":"renderer  <code>instance-attribute</code>","text":"<pre><code>renderer = AsyncTemplateEngine()\n</code></pre>"},{"location":"api/#plating.DocumentationPlater-functions","title":"Functions","text":""},{"location":"api/#plating.DocumentationPlater.generate_documentation","title":"generate_documentation  <code>async</code>","text":"<pre><code>generate_documentation(\n    output_dir: Path, component_type: str | None = None\n) -&gt; list[tuple[Path, str]]\n</code></pre> <p>Generate documentation for all discovered components.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>Path</code> <p>Directory to write generated documentation</p> required <code>component_type</code> <code>str | None</code> <p>Optional filter for component type</p> <code>None</code> <p>Returns:</p> Type Description <code>list[tuple[Path, str]]</code> <p>List of (file_path, content) tuples for generated files</p> Source code in <code>src/plating/generation/plater.py</code> <pre><code>async def generate_documentation(\n    self, output_dir: Path, component_type: str | None = None\n) -&gt; list[tuple[Path, str]]:\n    \"\"\"Generate documentation for all discovered components.\n\n    Args:\n        output_dir: Directory to write generated documentation\n        component_type: Optional filter for component type\n\n    Returns:\n        List of (file_path, content) tuples for generated files\n    \"\"\"\n    bundles = self.discovery.discover_bundles(component_type)\n    generated_files: list[tuple[Path, str]] = []\n\n    for bundle in bundles:\n        if isinstance(bundle, FunctionPlatingBundle):\n            files = await self._generate_function_documentation(bundle, output_dir)\n            generated_files.extend(files)\n        else:\n            files = await self._generate_component_documentation(bundle, output_dir)\n            generated_files.extend(files)\n\n    return generated_files\n</code></pre>"},{"location":"api/#plating.Plating","title":"Plating","text":"<pre><code>Plating(\n    context: PlatingContext, package_name: str | None = None\n)\n</code></pre> <p>Modern async API for all plating operations with foundation integration.</p> <p>Initialize plating API with foundation context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>PlatingContext</code> <p>PlatingContext with configuration (required)</p> required <code>package_name</code> <code>str | None</code> <p>Package to search for plating bundles, or None to search all packages</p> <code>None</code> Source code in <code>src/plating/plating.py</code> <pre><code>def __init__(\n    self, context: PlatingContext, package_name: str | None = None\n) -&gt; None:\n    \"\"\"Initialize plating API with foundation context.\n\n    Args:\n        context: PlatingContext with configuration (required)\n        package_name: Package to search for plating bundles, or None to search all packages\n    \"\"\"\n    self.context = context\n    self.package_name = package_name\n\n    # Foundation patterns\n    self.registry = get_plating_registry(package_name)\n\n    # Schema processing\n    self._provider_schema: dict[str, Any] | None = None\n\n    # Resilience patterns for file I/O and network operations\n    self.retry_policy = RetryPolicy(\n        max_attempts=3,\n        backoff=BackoffStrategy.EXPONENTIAL,\n        base_delay=0.5,\n        max_delay=10.0,\n        retryable_errors=(IOError, OSError, TimeoutError, ConnectionError),\n    )\n</code></pre>"},{"location":"api/#plating.Plating-attributes","title":"Attributes","text":""},{"location":"api/#plating.Plating.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context = context\n</code></pre>"},{"location":"api/#plating.Plating.package_name","title":"package_name  <code>instance-attribute</code>","text":"<pre><code>package_name = package_name\n</code></pre>"},{"location":"api/#plating.Plating.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry = get_plating_registry(package_name)\n</code></pre>"},{"location":"api/#plating.Plating.retry_policy","title":"retry_policy  <code>instance-attribute</code>","text":"<pre><code>retry_policy = RetryPolicy(\n    max_attempts=3,\n    backoff=EXPONENTIAL,\n    base_delay=0.5,\n    max_delay=10.0,\n    retryable_errors=(\n        IOError,\n        OSError,\n        TimeoutError,\n        ConnectionError,\n    ),\n)\n</code></pre>"},{"location":"api/#plating.Plating-functions","title":"Functions","text":""},{"location":"api/#plating.Plating.adorn","title":"adorn  <code>async</code>","text":"<pre><code>adorn(\n    output_dir: Path | None = None,\n    component_types: list[ComponentType] | None = None,\n    templates_only: bool = False,\n) -&gt; AdornResult\n</code></pre> <p>Generate template structure for discovered components.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>Path | None</code> <p>Directory to write templates (default: .plating)</p> <code>None</code> <code>component_types</code> <code>list[ComponentType] | None</code> <p>Specific component types to adorn</p> <code>None</code> <code>templates_only</code> <code>bool</code> <p>Only generate templates, skip discovery</p> <code>False</code> <p>Returns:</p> Type Description <code>AdornResult</code> <p>AdornResult with generation statistics</p> Source code in <code>src/plating/plating.py</code> <pre><code>@with_timing\n@with_retry()\n@with_metrics(\"adorn\")\nasync def adorn(\n    self,\n    output_dir: Path | None = None,\n    component_types: list[ComponentType] | None = None,\n    templates_only: bool = False,\n) -&gt; AdornResult:\n    \"\"\"Generate template structure for discovered components.\n\n    Args:\n        output_dir: Directory to write templates (default: .plating)\n        component_types: Specific component types to adorn\n        templates_only: Only generate templates, skip discovery\n\n    Returns:\n        AdornResult with generation statistics\n    \"\"\"\n    if not component_types:\n        component_types = [ComponentType.RESOURCE, ComponentType.DATA_SOURCE, ComponentType.FUNCTION]\n\n    output_dir = output_dir or Path(\".plating\")\n\n    try:\n        output_dir.mkdir(parents=True, exist_ok=True)\n    except (PermissionError, OSError) as e:\n        logger.error(\"Failed to create adorn output directory\", path=output_dir, error=str(e))\n        raise FileSystemError(\n            path=output_dir, operation=\"create directory\", reason=str(e), caused_by=e\n        ) from e\n\n    pout(f\"\ud83c\udfa8 Starting adorn for {len(component_types)} component type(s)\")\n\n    start_time = time.monotonic()\n    templates_generated = 0\n    errors = []\n\n    for component_type in component_types:\n        components = self.registry.get_components(component_type)\n        logger.info(f\"Found {len(components)} {component_type.value} components to adorn\")\n        pout(f\"\ud83d\udce6 Processing {len(components)} {component_type.value}(s)...\")\n\n        generated_for_type = 0\n        for component in components:\n            try:\n                # Skip generating stub templates if source templates already exist\n                if component.has_main_template():\n                    logger.debug(f\"Skipping {component.name} - source template already exists\")\n                    continue\n\n                # Only generate stub templates for components that don't have source templates\n                template_dir = output_dir / component_type.output_subdir / component.name\n\n                try:\n                    template_dir.mkdir(parents=True, exist_ok=True)\n                except (PermissionError, OSError) as e:\n                    raise FileSystemError(\n                        path=template_dir, operation=\"create directory\", reason=str(e), caused_by=e\n                    ) from e\n\n                # Generate basic template only if it doesn't exist in source\n                template_file = template_dir / f\"{component.name}.tmpl.md\"\n                if not template_file.exists():\n                    try:\n                        generate_template(component, template_file)\n                        templates_generated += 1\n                        generated_for_type += 1\n                        logger.info(\n                            f\"Generated stub template for {component.name} (no source template found)\"\n                        )\n                    except OSError as e:\n                        raise FileSystemError(\n                            path=template_file, operation=\"write\", reason=str(e), caused_by=e\n                        ) from e\n\n            except FileSystemError:\n                raise\n            except Exception as e:\n                error_msg = f\"Failed to adorn {component.name}: {e}\"\n                logger.error(error_msg, component=component.name, error=str(e))\n                errors.append(error_msg)\n\n        if generated_for_type &gt; 0:\n            pout(f\"   \u2705 Generated {generated_for_type} template(s)\")\n        else:\n            pout(f\"   \u2139\ufe0f  All {component_type.value}s already have templates\")\n\n    duration = time.monotonic() - start_time\n    if templates_generated &gt; 0:\n        pout(f\"\\n\u2705 Adorning complete: {templates_generated} template(s) in {duration:.2f}s\")\n    else:\n        pout(\"\\n\u2139\ufe0f  No new templates needed\")\n\n    return AdornResult(\n        components_processed=sum(len(self.registry.get_components(ct)) for ct in component_types),\n        templates_generated=templates_generated,\n        examples_created=0,\n        errors=errors,\n    )\n</code></pre>"},{"location":"api/#plating.Plating.plate","title":"plate  <code>async</code>","text":"<pre><code>plate(\n    output_dir: Path | None = None,\n    component_types: list[ComponentType] | None = None,\n    force: bool = False,\n    validate_markdown: bool = True,\n    project_root: Path | None = None,\n) -&gt; PlateResult\n</code></pre> <p>Generate documentation from plating bundles.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>Path | None</code> <p>Output directory for documentation</p> <code>None</code> <code>component_types</code> <code>list[ComponentType] | None</code> <p>Component types to generate</p> <code>None</code> <code>force</code> <code>bool</code> <p>Overwrite existing files</p> <code>False</code> <code>validate_markdown</code> <code>bool</code> <p>Enable markdown validation</p> <code>True</code> <code>project_root</code> <code>Path | None</code> <p>Project root directory (auto-detected if not provided)</p> <code>None</code> <p>Returns:</p> Type Description <code>PlateResult</code> <p>PlateResult with generation statistics</p> Source code in <code>src/plating/plating.py</code> <pre><code>@with_timing\n@with_retry()\n@with_metrics(\"plate\")\nasync def plate(\n    self,\n    output_dir: Path | None = None,\n    component_types: list[ComponentType] | None = None,\n    force: bool = False,\n    validate_markdown: bool = True,\n    project_root: Path | None = None,\n) -&gt; PlateResult:\n    \"\"\"Generate documentation from plating bundles.\n\n    Args:\n        output_dir: Output directory for documentation\n        component_types: Component types to generate\n        force: Overwrite existing files\n        validate_markdown: Enable markdown validation\n        project_root: Project root directory (auto-detected if not provided)\n\n    Returns:\n        PlateResult with generation statistics\n    \"\"\"\n    # Detect project root if not provided\n    if project_root is None:\n        project_root = find_project_root()\n\n    # Determine final output directory with improved logic\n    final_output_dir = get_output_directory(output_dir, project_root)\n\n    logger.info(f\"Using output directory: {final_output_dir}\")\n    if project_root:\n        logger.info(f\"Project root detected: {project_root}\")\n    else:\n        logger.warning(\"No project root detected, using current directory as base\")\n\n    # Validate and create output directory\n    try:\n        final_output_dir.mkdir(parents=True, exist_ok=True)\n    except (PermissionError, OSError) as e:\n        logger.error(\"Failed to create output directory\", path=final_output_dir, error=str(e))\n        raise FileSystemError(\n            path=final_output_dir, operation=\"create directory\", reason=str(e), caused_by=e\n        ) from e\n\n    # Ensure we can write to the directory\n    if not os.access(final_output_dir, os.W_OK):\n        logger.error(\"Output directory is not writable\", path=final_output_dir)\n        raise FileSystemError(\n            path=final_output_dir,\n            operation=\"write\",\n            reason=\"Directory is not writable (check permissions)\",\n        )\n\n    if not component_types:\n        component_types = [ComponentType.RESOURCE, ComponentType.DATA_SOURCE, ComponentType.FUNCTION]\n\n    pout(f\"\ud83c\udf7d\ufe0f  Plating documentation to: {final_output_dir}\")\n    pout(f\"\ud83d\udce6 Processing {len(component_types)} component type(s)\")\n\n    start_time = time.monotonic()\n    result = PlateResult(duration_seconds=0.0, files_generated=0, errors=[], output_files=[])\n\n    # Track unique bundles processed\n    processed_bundles: set[str] = set()\n\n    for component_type in component_types:\n        components = self.registry.get_components_with_templates(component_type)\n        logger.info(f\"Generating docs for {len(components)} {component_type.value} components\")\n        pout(f\"\ud83d\udcc4 Rendering {len(components)} {component_type.value}(s)...\")\n\n        # Track unique bundle directories\n        for component in components:\n            processed_bundles.add(str(component.plating_dir))\n\n        files_before = result.files_generated\n        await render_component_docs(\n            components,\n            component_type,\n            final_output_dir,\n            force,\n            result,\n            self.context,\n            self._provider_schema or {},\n        )\n        files_for_type = result.files_generated - files_before\n        if files_for_type &gt; 0:\n            pout(f\"   \u2705 Generated {files_for_type} file(s)\")\n\n    # Generate provider index page\n    pout(\"\ud83d\udcdd Generating provider index...\")\n    generate_provider_index(\n        final_output_dir, force, result, self.context, self._provider_schema or {}, self.registry\n    )\n\n    # Update result with tracking info\n    result.bundles_processed = len(processed_bundles)\n    result.duration_seconds = time.monotonic() - start_time\n\n    pout(f\"\\n\u2705 Plating complete: {result.files_generated} file(s) in {result.duration_seconds:.2f}s\")\n\n    # Validate if requested (disabled due to markdown validator dependency)\n    # if validate_markdown and result.output_files:\n    #     validation_result = await self.validate(output_dir, component_types)\n    #     result.errors.extend(validation_result.errors)\n\n    return result\n</code></pre>"},{"location":"api/#plating.Plating.validate","title":"validate  <code>async</code>","text":"<pre><code>validate(\n    output_dir: Path | None = None,\n    component_types: list[ComponentType] | None = None,\n    project_root: Path | None = None,\n) -&gt; ValidationResult\n</code></pre> <p>Validate generated documentation.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>Path | None</code> <p>Directory containing documentation</p> <code>None</code> <code>component_types</code> <code>list[ComponentType] | None</code> <p>Component types to validate</p> <code>None</code> <code>project_root</code> <code>Path | None</code> <p>Project root directory (auto-detected if not provided)</p> <code>None</code> <p>Returns:</p> Type Description <code>ValidationResult</code> <p>ValidationResult with any errors found</p> Source code in <code>src/plating/plating.py</code> <pre><code>@with_timing\n@with_metrics(\"validate\")\nasync def validate(\n    self,\n    output_dir: Path | None = None,\n    component_types: list[ComponentType] | None = None,\n    project_root: Path | None = None,\n) -&gt; ValidationResult:\n    \"\"\"Validate generated documentation.\n\n    Args:\n        output_dir: Directory containing documentation\n        component_types: Component types to validate\n        project_root: Project root directory (auto-detected if not provided)\n\n    Returns:\n        ValidationResult with any errors found\n    \"\"\"\n    # Use same logic as plate method for consistency\n    if project_root is None:\n        project_root = find_project_root()\n\n    final_output_dir = get_output_directory(output_dir, project_root)\n    component_types = component_types or [\n        ComponentType.RESOURCE,\n        ComponentType.DATA_SOURCE,\n        ComponentType.FUNCTION,\n    ]\n\n    errors = []\n    files_checked = 0\n    passed = 0\n\n    for component_type in component_types:\n        type_dir = final_output_dir / component_type.output_subdir\n        if not type_dir.exists():\n            continue\n\n        for md_file in type_dir.glob(\"*.md\"):\n            try:\n                # For now, just simulate validation (since markdown validator is disabled)\n                files_checked += 1\n                passed += 1  # Assume validation passes\n            except Exception as e:\n                errors.append(f\"Failed to validate {md_file}: {e}\")\n\n    return ValidationResult(\n        total=files_checked,\n        passed=passed,\n        failed=len(errors),\n        skipped=0,\n        duration_seconds=0.0,\n        errors=errors,\n    )\n</code></pre>"},{"location":"api/#plating.Plating.get_registry_stats","title":"get_registry_stats","text":"<pre><code>get_registry_stats() -&gt; dict[str, Any]\n</code></pre> <p>Get registry statistics.</p> Source code in <code>src/plating/plating.py</code> <pre><code>def get_registry_stats(self) -&gt; dict[str, Any]:\n    \"\"\"Get registry statistics.\"\"\"\n    stats = {\"total_components\": 0, \"component_types\": []}\n\n    for component_type in [ComponentType.RESOURCE, ComponentType.DATA_SOURCE, ComponentType.FUNCTION]:\n        components = self.registry.get_components(component_type)\n        with_templates = self.registry.get_components_with_templates(component_type)\n\n        stats[component_type.value] = {\n            \"total\": len(components),\n            \"with_templates\": len(with_templates),\n        }\n        stats[\"total_components\"] += len(components)\n        if components:\n            stats[\"component_types\"].append(component_type.value)\n\n    return stats\n</code></pre>"},{"location":"api/#plating.PlatingRegistry","title":"PlatingRegistry","text":"<pre><code>PlatingRegistry(package_name: str | None = None)\n</code></pre> <p>               Bases: <code>Registry</code></p> <p>Component registry using foundation Registry pattern with ComponentSet support.</p> <p>Initialize registry with package discovery.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str | None</code> <p>Package to search for plating bundles, or None to search all packages</p> <code>None</code> Source code in <code>src/plating/registry.py</code> <pre><code>def __init__(self, package_name: str | None = None) -&gt; None:\n    \"\"\"Initialize registry with package discovery.\n\n    Args:\n        package_name: Package to search for plating bundles, or None to search all packages\n    \"\"\"\n    super().__init__()\n    self.package_name = package_name\n\n    # Foundation resilience for discovery\n    self._retry_policy = RetryPolicy(\n        max_attempts=3,\n        backoff=BackoffStrategy.EXPONENTIAL,\n        base_delay=0.5,\n        max_delay=5.0,\n        retryable_errors=(OSError, ImportError, AttributeError),\n    )\n    self._retry_executor = RetryExecutor(self._retry_policy)\n\n    # Initialize discovery with error handling\n    try:\n        self._discovery = PlatingDiscovery(package_name)\n        # Auto-discover on initialization\n        self._discover_and_register()\n    except Exception as e:\n        scope = package_name if package_name else \"all packages\"\n        logger.error(f\"Failed to initialize discovery for {scope}: {e}\")\n        # Set discovery to None so we can still create the registry\n        self._discovery = None\n</code></pre>"},{"location":"api/#plating.PlatingRegistry-attributes","title":"Attributes","text":""},{"location":"api/#plating.PlatingRegistry.package_name","title":"package_name  <code>instance-attribute</code>","text":"<pre><code>package_name = package_name\n</code></pre>"},{"location":"api/#plating.PlatingRegistry-functions","title":"Functions","text":""},{"location":"api/#plating.PlatingRegistry.get_components","title":"get_components","text":"<pre><code>get_components(\n    component_type: ComponentType,\n) -&gt; list[PlatingBundle]\n</code></pre> <p>Get all components of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <code>ComponentType</code> <p>The component type to filter by</p> required <p>Returns:</p> Type Description <code>list[PlatingBundle]</code> <p>List of PlatingBundle objects</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_components(self, component_type: ComponentType) -&gt; list[PlatingBundle]:\n    \"\"\"Get all components of a specific type.\n\n    Args:\n        component_type: The component type to filter by\n\n    Returns:\n        List of PlatingBundle objects\n    \"\"\"\n    names = self.list_dimension(component_type.value)\n    entries = []\n    for name in names:\n        entry = self.get_entry(name=name, dimension=component_type.value)\n        if entry:\n            entries.append(entry)\n    return [entry.value.bundle for entry in entries]\n</code></pre>"},{"location":"api/#plating.PlatingRegistry.get_component","title":"get_component","text":"<pre><code>get_component(\n    component_type: ComponentType, name: str\n) -&gt; PlatingBundle | None\n</code></pre> <p>Get a specific component by type and name.</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <code>ComponentType</code> <p>The component type</p> required <code>name</code> <code>str</code> <p>The component name</p> required <p>Returns:</p> Type Description <code>PlatingBundle | None</code> <p>PlatingBundle if found, None otherwise</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_component(self, component_type: ComponentType, name: str) -&gt; PlatingBundle | None:\n    \"\"\"Get a specific component by type and name.\n\n    Args:\n        component_type: The component type\n        name: The component name\n\n    Returns:\n        PlatingBundle if found, None otherwise\n    \"\"\"\n    entry = self.get_entry(name=name, dimension=component_type.value)\n    return entry.value.bundle if entry else None\n</code></pre>"},{"location":"api/#plating.PlatingRegistry.get_components_with_templates","title":"get_components_with_templates","text":"<pre><code>get_components_with_templates(\n    component_type: ComponentType,\n) -&gt; list[PlatingBundle]\n</code></pre> <p>Get components of a type that have templates.</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <code>ComponentType</code> <p>The component type to filter by</p> required <p>Returns:</p> Type Description <code>list[PlatingBundle]</code> <p>List of PlatingBundle objects with templates</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_components_with_templates(self, component_type: ComponentType) -&gt; list[PlatingBundle]:\n    \"\"\"Get components of a type that have templates.\n\n    Args:\n        component_type: The component type to filter by\n\n    Returns:\n        List of PlatingBundle objects with templates\n    \"\"\"\n    components = self.get_components(component_type)\n    return [bundle for bundle in components if bundle.has_main_template()]\n</code></pre>"},{"location":"api/#plating.PlatingRegistry.get_components_with_examples","title":"get_components_with_examples","text":"<pre><code>get_components_with_examples(\n    component_type: ComponentType,\n) -&gt; list[PlatingBundle]\n</code></pre> <p>Get components of a type that have examples.</p> <p>Parameters:</p> Name Type Description Default <code>component_type</code> <code>ComponentType</code> <p>The component type to filter by</p> required <p>Returns:</p> Type Description <code>list[PlatingBundle]</code> <p>List of PlatingBundle objects with examples</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_components_with_examples(self, component_type: ComponentType) -&gt; list[PlatingBundle]:\n    \"\"\"Get components of a type that have examples.\n\n    Args:\n        component_type: The component type to filter by\n\n    Returns:\n        List of PlatingBundle objects with examples\n    \"\"\"\n    components = self.get_components(component_type)\n    return [bundle for bundle in components if bundle.has_examples()]\n</code></pre>"},{"location":"api/#plating.PlatingRegistry.get_all_component_types","title":"get_all_component_types","text":"<pre><code>get_all_component_types() -&gt; list[ComponentType]\n</code></pre> <p>Get all registered component types.</p> <p>Returns:</p> Type Description <code>list[ComponentType]</code> <p>List of ComponentType enums found in registry</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_all_component_types(self) -&gt; list[ComponentType]:\n    \"\"\"Get all registered component types.\n\n    Returns:\n        List of ComponentType enums found in registry\n    \"\"\"\n    dimensions = self.list_all().keys()\n    component_types = []\n\n    for dimension in dimensions:\n        try:\n            comp_type = ComponentType(dimension)\n            component_types.append(comp_type)\n        except ValueError:\n            # Skip unknown component types\n            pass\n\n    return component_types\n</code></pre>"},{"location":"api/#plating.PlatingRegistry.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refresh the registry by re-discovering components.</p> Source code in <code>src/plating/registry.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refresh the registry by re-discovering components.\"\"\"\n    logger.info(\"Refreshing plating registry\")\n    self.clear()\n    self._discover_and_register()\n</code></pre>"},{"location":"api/#plating.PlatingRegistry.get_registry_stats","title":"get_registry_stats","text":"<pre><code>get_registry_stats() -&gt; dict[str, Any]\n</code></pre> <p>Get statistics about the registry contents.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with registry statistics</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_registry_stats(self) -&gt; dict[str, Any]:\n    \"\"\"Get statistics about the registry contents.\n\n    Returns:\n        Dictionary with registry statistics\n    \"\"\"\n    stats = {}\n    all_names = self.list_all()\n\n    stats[\"total_components\"] = sum(len(names) for names in all_names.values())\n    stats[\"component_types\"] = list(all_names.keys())\n\n    for comp_type, names in all_names.items():\n        stats[f\"{comp_type}_count\"] = len(names)\n\n        # Get actual entries to access metadata\n        entries = []\n        for name in names:\n            entry = self.get_entry(name=name, dimension=comp_type)\n            if entry:\n                entries.append(entry)\n\n        # Count bundles with templates/examples\n        bundles_with_templates = sum(\n            1 for entry in entries if entry.value.metadata.get(\"has_template\", False)\n        )\n        bundles_with_examples = sum(\n            1 for entry in entries if entry.value.metadata.get(\"has_examples\", False)\n        )\n\n        stats[f\"{comp_type}_with_templates\"] = bundles_with_templates\n        stats[f\"{comp_type}_with_examples\"] = bundles_with_examples\n\n    return stats\n</code></pre>"},{"location":"api/#plating.AsyncTemplateEngine","title":"AsyncTemplateEngine","text":"<pre><code>AsyncTemplateEngine()\n</code></pre> <p>Async-first template engine with foundation integration.</p> Source code in <code>src/plating/templating/engine.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._jinja_env = None\n    self._template_cache: dict[str, str] = {}\n</code></pre>"},{"location":"api/#plating.AsyncTemplateEngine-functions","title":"Functions","text":""},{"location":"api/#plating.AsyncTemplateEngine.render","title":"render  <code>async</code>","text":"<pre><code>render(\n    bundle: PlatingBundle, context: PlatingContext\n) -&gt; str\n</code></pre> <p>Render template with context and partials.</p> <p>Parameters:</p> Name Type Description Default <code>bundle</code> <code>PlatingBundle</code> <p>PlatingBundle containing template and assets</p> required <code>context</code> <code>PlatingContext</code> <p>Type-safe context for rendering</p> required <p>Returns:</p> Type Description <code>str</code> <p>Rendered template string</p> <p>Raises:</p> Type Description <code>TemplateError</code> <p>If template rendering fails</p> <code>FileSystemError</code> <p>If template loading fails</p> Source code in <code>src/plating/templating/engine.py</code> <pre><code>@with_timing\n@with_metrics(\"template_render\")\nasync def render(self, bundle: PlatingBundle, context: PlatingContext) -&gt; str:\n    \"\"\"Render template with context and partials.\n\n    Args:\n        bundle: PlatingBundle containing template and assets\n        context: Type-safe context for rendering\n\n    Returns:\n        Rendered template string\n\n    Raises:\n        TemplateError: If template rendering fails\n        FileSystemError: If template loading fails\n    \"\"\"\n    try:\n        # Load template and partials concurrently\n        template_task = asyncio.create_task(self._load_template(bundle))\n        partials_task = asyncio.create_task(self._load_partials(bundle))\n\n        template_content, partials = await asyncio.gather(template_task, partials_task)\n\n        if not template_content:\n            logger.debug(f\"No template found for {bundle.name}, skipping\")\n            return \"\"\n\n        # Prepare templates dict\n        templates = {\"main.tmpl\": template_content}\n        templates.update(partials)\n\n        # Create Jinja environment\n        env = self._get_jinja_env(templates)\n\n        # Convert context to dict\n        context_dict = context.to_dict()\n\n        # Override template functions with context-aware implementations\n        env.globals[\"example\"] = lambda key: self._format_example_with_context(key, context.examples)\n\n        # Override schema function to return actual schema\n        if context.schema:\n            env.globals[\"schema\"] = lambda: context.schema.to_markdown()\n        else:\n            env.globals[\"schema\"] = lambda: \"\"\n\n        # Render template asynchronously\n        template = env.get_template(\"main.tmpl\")\n\n        async with plating_metrics.track_operation(\"template_render\", bundle=bundle.name):\n            return await template.render_async(**context_dict)\n\n    except Jinja2TemplateError as e:\n        # Extract line number if available\n        line_number = getattr(e, \"lineno\", None)\n        error_msg = str(e)\n\n        logger.error(\n            \"Template rendering failed\",\n            bundle=bundle.name,\n            error=error_msg,\n            line_number=line_number,\n            **context.to_dict(),\n        )\n\n        raise TemplateError(\n            template_path=bundle.plating_dir / \"docs\" / f\"{bundle.name}.tmpl.md\",\n            reason=error_msg,\n            line_number=line_number,\n            context=getattr(e, \"source\", None),\n        ) from e\n\n    except OSError as e:\n        logger.error(\"File system error during template rendering\", bundle=bundle.name, error=str(e))\n        raise FileSystemError(\n            path=bundle.plating_dir,\n            operation=\"read template\",\n            reason=str(e),\n            caused_by=e,\n        ) from e\n\n    except Exception as e:\n        logger.exception(\"Unexpected error during template rendering\", bundle=bundle.name)\n        raise TemplateError(\n            template_path=bundle.plating_dir / \"docs\" / f\"{bundle.name}.tmpl.md\",\n            reason=f\"Unexpected error: {type(e).__name__}: {e}\",\n        ) from e\n</code></pre>"},{"location":"api/#plating.AsyncTemplateEngine.render_batch","title":"render_batch  <code>async</code>","text":"<pre><code>render_batch(\n    items: list[tuple[PlatingBundle, PlatingContext]],\n) -&gt; list[str]\n</code></pre> <p>Render multiple templates in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[tuple[PlatingBundle, PlatingContext]]</code> <p>List of (bundle, context) tuples to render</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of rendered template strings</p> <p>Raises:</p> Type Description <code>TemplateError</code> <p>If any template rendering fails</p> <code>FileSystemError</code> <p>If any template loading fails</p> Source code in <code>src/plating/templating/engine.py</code> <pre><code>@with_timing\n@with_metrics(\"template_render_batch\")\nasync def render_batch(self, items: list[tuple[PlatingBundle, PlatingContext]]) -&gt; list[str]:\n    \"\"\"Render multiple templates in parallel.\n\n    Args:\n        items: List of (bundle, context) tuples to render\n\n    Returns:\n        List of rendered template strings\n\n    Raises:\n        TemplateError: If any template rendering fails\n        FileSystemError: If any template loading fails\n    \"\"\"\n    tasks = [asyncio.create_task(self.render(bundle, context)) for bundle, context in items]\n\n    async with plating_metrics.track_operation(\"batch_render\", count=len(items)):\n        return await asyncio.gather(*tasks)\n</code></pre>"},{"location":"api/#plating.AsyncTemplateEngine.clear_cache","title":"clear_cache","text":"<pre><code>clear_cache() -&gt; None\n</code></pre> <p>Clear template cache.</p> Source code in <code>src/plating/templating/engine.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear template cache.\"\"\"\n    self._template_cache.clear()\n</code></pre>"},{"location":"api/#plating.TemplateMetadataExtractor","title":"TemplateMetadataExtractor","text":"<pre><code>TemplateMetadataExtractor()\n</code></pre> <p>Extracts metadata from function implementations for template rendering.</p> Source code in <code>src/plating/templating/metadata.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.config = get_config()\n</code></pre>"},{"location":"api/#plating.TemplateMetadataExtractor-attributes","title":"Attributes","text":""},{"location":"api/#plating.TemplateMetadataExtractor.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = get_config()\n</code></pre>"},{"location":"api/#plating.TemplateMetadataExtractor-functions","title":"Functions","text":""},{"location":"api/#plating.TemplateMetadataExtractor.extract_function_metadata","title":"extract_function_metadata","text":"<pre><code>extract_function_metadata(\n    function_name: str, component_type: str\n) -&gt; dict[str, Any]\n</code></pre> <p>Extract metadata for a function to populate templates.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>str</code> <p>Name of the function</p> required <code>component_type</code> <code>str</code> <p>Type of component (function, resource, etc.)</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing metadata for template rendering</p> Source code in <code>src/plating/templating/metadata.py</code> <pre><code>def extract_function_metadata(self, function_name: str, component_type: str) -&gt; dict[str, Any]:\n    \"\"\"Extract metadata for a function to populate templates.\n\n    Args:\n        function_name: Name of the function\n        component_type: Type of component (function, resource, etc.)\n\n    Returns:\n        Dictionary containing metadata for template rendering\n    \"\"\"\n    return self._generate_function_metadata(function_name)\n</code></pre>"},{"location":"api/#plating.TemplateMetadataExtractor.discover_template_files","title":"discover_template_files","text":"<pre><code>discover_template_files(docs_dir: Path) -&gt; list[Path]\n</code></pre> <p>Discover all template files in a docs directory.</p> <p>Parameters:</p> Name Type Description Default <code>docs_dir</code> <code>Path</code> <p>Directory containing template files</p> required <p>Returns:</p> Type Description <code>list[Path]</code> <p>List of template file paths</p> Source code in <code>src/plating/templating/metadata.py</code> <pre><code>def discover_template_files(self, docs_dir: Path) -&gt; list[Path]:\n    \"\"\"Discover all template files in a docs directory.\n\n    Args:\n        docs_dir: Directory containing template files\n\n    Returns:\n        List of template file paths\n    \"\"\"\n    if not docs_dir.exists():\n        return []\n\n    template_files = []\n    for template_file in docs_dir.glob(\"*.tmpl.md\"):\n        template_files.append(template_file)\n\n    return template_files\n</code></pre>"},{"location":"api/#plating.AdornResult","title":"AdornResult","text":"<p>Result from adorn operations.</p>"},{"location":"api/#plating.AdornResult-attributes","title":"Attributes","text":""},{"location":"api/#plating.AdornResult.components_processed","title":"components_processed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>components_processed: int = 0\n</code></pre>"},{"location":"api/#plating.AdornResult.templates_generated","title":"templates_generated  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>templates_generated: int = 0\n</code></pre>"},{"location":"api/#plating.AdornResult.examples_created","title":"examples_created  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>examples_created: int = 0\n</code></pre>"},{"location":"api/#plating.AdornResult.errors","title":"errors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>errors: list[str] = field(factory=list)\n</code></pre>"},{"location":"api/#plating.AdornResult.success","title":"success  <code>property</code>","text":"<pre><code>success: bool\n</code></pre> <p>Whether the operation succeeded.</p>"},{"location":"api/#plating.ArgumentInfo","title":"ArgumentInfo","text":"<p>Information about a function argument.</p>"},{"location":"api/#plating.ArgumentInfo-attributes","title":"Attributes","text":""},{"location":"api/#plating.ArgumentInfo.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/#plating.ArgumentInfo.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str\n</code></pre>"},{"location":"api/#plating.ArgumentInfo.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre>"},{"location":"api/#plating.ArgumentInfo.required","title":"required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>required: bool = True\n</code></pre>"},{"location":"api/#plating.ArgumentInfo-functions","title":"Functions","text":""},{"location":"api/#plating.ArgumentInfo.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert to dictionary for serialization.</p> Source code in <code>src/plating/types.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert to dictionary for serialization.\"\"\"\n    return {\n        \"name\": self.name,\n        \"type\": self.type,\n        \"description\": self.description,\n        \"required\": self.required,\n    }\n</code></pre>"},{"location":"api/#plating.ArgumentInfo.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[str, Any]) -&gt; ArgumentInfo\n</code></pre> <p>Create from dictionary.</p> Source code in <code>src/plating/types.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; \"ArgumentInfo\":\n    \"\"\"Create from dictionary.\"\"\"\n    return cls(\n        name=data.get(\"name\", \"\"),\n        type=data.get(\"type\", \"\"),\n        description=data.get(\"description\", \"\"),\n        required=data.get(\"required\", True),\n    )\n</code></pre>"},{"location":"api/#plating.ComponentType","title":"ComponentType","text":"<p>               Bases: <code>Enum</code></p> <p>Type-safe component types for Terraform/OpenTofu providers.</p> <p>Supported types: - RESOURCE: Terraform resources - DATA_SOURCE: Terraform data sources - FUNCTION: Provider-defined functions - PROVIDER: Provider configuration</p>"},{"location":"api/#plating.ComponentType-attributes","title":"Attributes","text":""},{"location":"api/#plating.ComponentType.RESOURCE","title":"RESOURCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESOURCE = 'resource'\n</code></pre>"},{"location":"api/#plating.ComponentType.DATA_SOURCE","title":"DATA_SOURCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATA_SOURCE = 'data_source'\n</code></pre>"},{"location":"api/#plating.ComponentType.FUNCTION","title":"FUNCTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FUNCTION = 'function'\n</code></pre>"},{"location":"api/#plating.ComponentType.PROVIDER","title":"PROVIDER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROVIDER = 'provider'\n</code></pre>"},{"location":"api/#plating.ComponentType.display_name","title":"display_name  <code>property</code>","text":"<pre><code>display_name: str\n</code></pre> <p>Get the formatted display name.</p>"},{"location":"api/#plating.ComponentType.output_subdir","title":"output_subdir  <code>property</code>","text":"<pre><code>output_subdir: str\n</code></pre> <p>Get the output subdirectory name for Terraform Registry structure.</p>"},{"location":"api/#plating.PlateResult","title":"PlateResult","text":"<p>Result from plate operations.</p>"},{"location":"api/#plating.PlateResult-attributes","title":"Attributes","text":""},{"location":"api/#plating.PlateResult.bundles_processed","title":"bundles_processed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bundles_processed: int = 0\n</code></pre>"},{"location":"api/#plating.PlateResult.files_generated","title":"files_generated  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files_generated: int = 0\n</code></pre>"},{"location":"api/#plating.PlateResult.duration_seconds","title":"duration_seconds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duration_seconds: float = 0.0\n</code></pre>"},{"location":"api/#plating.PlateResult.errors","title":"errors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>errors: list[str] = field(factory=list)\n</code></pre>"},{"location":"api/#plating.PlateResult.output_files","title":"output_files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_files: list[Path] = field(factory=list)\n</code></pre>"},{"location":"api/#plating.PlateResult.success","title":"success  <code>property</code>","text":"<pre><code>success: bool\n</code></pre> <p>Whether the operation succeeded.</p>"},{"location":"api/#plating.SchemaInfo","title":"SchemaInfo","text":"<p>Structured schema information.</p>"},{"location":"api/#plating.SchemaInfo-attributes","title":"Attributes","text":""},{"location":"api/#plating.SchemaInfo.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre>"},{"location":"api/#plating.SchemaInfo.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, dict] = field(factory=dict)\n</code></pre>"},{"location":"api/#plating.SchemaInfo.blocks","title":"blocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocks: dict[str, dict] = field(factory=dict)\n</code></pre>"},{"location":"api/#plating.SchemaInfo-functions","title":"Functions","text":""},{"location":"api/#plating.SchemaInfo.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(schema_dict: dict) -&gt; SchemaInfo\n</code></pre> <p>Create SchemaInfo from a raw schema dictionary.</p> Source code in <code>src/plating/types.py</code> <pre><code>@classmethod\ndef from_dict(cls, schema_dict: dict) -&gt; \"SchemaInfo\":\n    \"\"\"Create SchemaInfo from a raw schema dictionary.\"\"\"\n    if not schema_dict:\n        return cls()\n\n    block = schema_dict.get(\"block\", {})\n    return cls(\n        description=schema_dict.get(\"description\", \"\"),\n        attributes=block.get(\"attributes\", {}),\n        blocks=block.get(\"block_types\", {}),\n    )\n</code></pre>"},{"location":"api/#plating.SchemaInfo.to_markdown","title":"to_markdown","text":"<pre><code>to_markdown() -&gt; str\n</code></pre> <p>Convert schema to markdown format.</p> Source code in <code>src/plating/types.py</code> <pre><code>def to_markdown(self) -&gt; str:\n    \"\"\"Convert schema to markdown format.\"\"\"\n    if not self.attributes and not self.blocks:\n        return \"\"\n\n    lines = [\"## Schema\", \"\"]\n\n    # Group attributes by type\n    required_attrs = []\n    optional_attrs = []\n    computed_attrs = []\n\n    for attr_name, attr_def in self.attributes.items():\n        attr_type = self._format_type(attr_def.get(\"type\"))\n        description = attr_def.get(\"description\", \"\")\n\n        if attr_def.get(\"required\"):\n            required_attrs.append((attr_name, attr_type, description))\n        elif attr_def.get(\"computed\") and not attr_def.get(\"optional\"):\n            computed_attrs.append((attr_name, attr_type, description))\n        else:\n            optional_attrs.append((attr_name, attr_type, description))\n\n    # Format sections\n    if required_attrs:\n        lines.extend([\"### Required\", \"\"])\n        for name, type_str, desc in required_attrs:\n            lines.append(f\"- `{name}` ({type_str}) - {desc}\")\n        lines.append(\"\")\n\n    if optional_attrs:\n        lines.extend([\"### Optional\", \"\"])\n        for name, type_str, desc in optional_attrs:\n            lines.append(f\"- `{name}` ({type_str}) - {desc}\")\n        lines.append(\"\")\n\n    if computed_attrs:\n        lines.extend([\"### Read-Only\", \"\"])\n        for name, type_str, desc in computed_attrs:\n            lines.append(f\"- `{name}` ({type_str}) - {desc}\")\n        lines.append(\"\")\n\n    # Handle nested blocks\n    if self.blocks:\n        lines.extend([\"### Blocks\", \"\"])\n        for block_name, block_def in self.blocks.items():\n            max_items = block_def.get(\"max_items\", 0)\n            if max_items == 1:\n                lines.append(f\"- `{block_name}` (Optional)\")\n            else:\n                lines.append(f\"- `{block_name}` (Optional, List)\")\n        lines.append(\"\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/#plating.ValidationResult","title":"ValidationResult","text":"<p>Result from validation operations with markdown linting support.</p>"},{"location":"api/#plating.ValidationResult-attributes","title":"Attributes","text":""},{"location":"api/#plating.ValidationResult.total","title":"total  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total: int = 0\n</code></pre>"},{"location":"api/#plating.ValidationResult.passed","title":"passed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>passed: int = 0\n</code></pre>"},{"location":"api/#plating.ValidationResult.failed","title":"failed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>failed: int = 0\n</code></pre>"},{"location":"api/#plating.ValidationResult.skipped","title":"skipped  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>skipped: int = 0\n</code></pre>"},{"location":"api/#plating.ValidationResult.duration_seconds","title":"duration_seconds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duration_seconds: float = 0.0\n</code></pre>"},{"location":"api/#plating.ValidationResult.failures","title":"failures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>failures: dict[str, str] = field(factory=dict)\n</code></pre>"},{"location":"api/#plating.ValidationResult.errors","title":"errors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>errors: list[str] = field(factory=list)\n</code></pre>"},{"location":"api/#plating.ValidationResult.lint_errors","title":"lint_errors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lint_errors: list[str] = field(factory=list)\n</code></pre>"},{"location":"api/#plating.ValidationResult.terraform_version","title":"terraform_version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>terraform_version: str = ''\n</code></pre>"},{"location":"api/#plating.ValidationResult.success","title":"success  <code>property</code>","text":"<pre><code>success: bool\n</code></pre> <p>Whether all validations passed.</p>"},{"location":"api/#plating-functions","title":"Functions","text":""},{"location":"api/#plating.with_circuit_breaker","title":"with_circuit_breaker","text":"<pre><code>with_circuit_breaker(\n    failure_threshold: int = 3,\n    recovery_timeout: float = 30.0,\n    expected_exception: type[Exception] = Exception,\n) -&gt; Callable[[F], F]\n</code></pre> <p>Decorator for circuit breaker protection.</p> <p>Parameters:</p> Name Type Description Default <code>failure_threshold</code> <code>int</code> <p>Number of failures before opening circuit</p> <code>3</code> <code>recovery_timeout</code> <code>float</code> <p>Time to wait before attempting recovery</p> <code>30.0</code> <code>expected_exception</code> <code>type[Exception]</code> <p>Exception type that triggers circuit breaker</p> <code>Exception</code> Source code in <code>src/plating/decorators.py</code> <pre><code>def with_circuit_breaker(\n    failure_threshold: int = 3, recovery_timeout: float = 30.0, expected_exception: type[Exception] = Exception\n) -&gt; Callable[[F], F]:\n    \"\"\"Decorator for circuit breaker protection.\n\n    Args:\n        failure_threshold: Number of failures before opening circuit\n        recovery_timeout: Time to wait before attempting recovery\n        expected_exception: Exception type that triggers circuit breaker\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        circuit = SyncCircuitBreaker(\n            failure_threshold=failure_threshold,\n            recovery_timeout=recovery_timeout,\n            expected_exception=expected_exception,\n        )\n\n        if asyncio.iscoroutinefunction(func):\n\n            @functools.wraps(func)\n            async def async_wrapper(*args, **kwargs):\n                return await circuit.call_async(func, *args, **kwargs)\n\n            return async_wrapper\n        else:\n\n            @functools.wraps(func)\n            def sync_wrapper(*args, **kwargs):\n                return circuit.call(func, *args, **kwargs)\n\n            return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/#plating.with_metrics","title":"with_metrics","text":"<pre><code>with_metrics(operation_name: str) -&gt; Callable[[F], F]\n</code></pre> <p>Decorator for automatic metrics collection via structured logging.</p> <p>Parameters:</p> Name Type Description Default <code>operation_name</code> <code>str</code> <p>Name for the operation metrics</p> required Source code in <code>src/plating/decorators.py</code> <pre><code>def with_metrics(operation_name: str) -&gt; Callable[[F], F]:\n    \"\"\"Decorator for automatic metrics collection via structured logging.\n\n    Args:\n        operation_name: Name for the operation metrics\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        if asyncio.iscoroutinefunction(func):\n\n            @functools.wraps(func)\n            async def async_wrapper(*args, **kwargs):\n                start = time.perf_counter()\n                try:\n                    result = await func(*args, **kwargs)\n                    duration = time.perf_counter() - start\n                    logger.info(\n                        f\"Operation {operation_name} completed\",\n                        operation=operation_name,\n                        status=\"success\",\n                        duration_seconds=duration,\n                    )\n                    return result\n                except Exception as e:\n                    duration = time.perf_counter() - start\n                    logger.error(\n                        f\"Operation {operation_name} failed\",\n                        operation=operation_name,\n                        status=\"error\",\n                        error=type(e).__name__,\n                        duration_seconds=duration,\n                    )\n                    raise\n\n            return async_wrapper\n        else:\n\n            @functools.wraps(func)\n            def sync_wrapper(*args, **kwargs):\n                start = time.perf_counter()\n                try:\n                    result = func(*args, **kwargs)\n                    duration = time.perf_counter() - start\n                    logger.info(\n                        f\"Operation {operation_name} completed\",\n                        operation=operation_name,\n                        status=\"success\",\n                        duration_seconds=duration,\n                    )\n                    return result\n                except Exception as e:\n                    duration = time.perf_counter() - start\n                    logger.error(\n                        f\"Operation {operation_name} failed\",\n                        operation=operation_name,\n                        status=\"error\",\n                        error=type(e).__name__,\n                        duration_seconds=duration,\n                    )\n                    raise\n\n            return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/#plating.with_retry","title":"with_retry","text":"<pre><code>with_retry(\n    max_attempts: int = 3,\n    backoff: str = \"exponential\",\n    base_delay: float = 1.0,\n    max_delay: float = 60.0,\n    retryable_errors: tuple[type[Exception], ...] = (\n        Exception,\n    ),\n) -&gt; Callable[[F], F]\n</code></pre> <p>Decorator for automatic retry with exponential backoff.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <code>int</code> <p>Maximum number of retry attempts</p> <code>3</code> <code>backoff</code> <code>str</code> <p>Backoff strategy (\"exponential\", \"linear\", \"constant\")</p> <code>'exponential'</code> <code>base_delay</code> <code>float</code> <p>Base delay between retries</p> <code>1.0</code> <code>max_delay</code> <code>float</code> <p>Maximum delay between retries</p> <code>60.0</code> <code>retryable_errors</code> <code>tuple[type[Exception], ...]</code> <p>Tuple of exception types that should trigger retry</p> <code>(Exception,)</code> Source code in <code>src/plating/decorators.py</code> <pre><code>def with_retry(\n    max_attempts: int = 3,\n    backoff: str = \"exponential\",\n    base_delay: float = 1.0,\n    max_delay: float = 60.0,\n    retryable_errors: tuple[type[Exception], ...] = (Exception,),\n) -&gt; Callable[[F], F]:\n    \"\"\"Decorator for automatic retry with exponential backoff.\n\n    Args:\n        max_attempts: Maximum number of retry attempts\n        backoff: Backoff strategy (\"exponential\", \"linear\", \"constant\")\n        base_delay: Base delay between retries\n        max_delay: Maximum delay between retries\n        retryable_errors: Tuple of exception types that should trigger retry\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        # Convert string to BackoffStrategy enum\n        backoff_strategy = {\n            \"exponential\": BackoffStrategy.EXPONENTIAL,\n            \"linear\": BackoffStrategy.LINEAR,\n            \"fixed\": BackoffStrategy.FIXED,\n            \"constant\": BackoffStrategy.FIXED,  # Map constant to fixed\n        }.get(backoff, BackoffStrategy.EXPONENTIAL)\n\n        retry_policy = RetryPolicy(\n            max_attempts=max_attempts,\n            backoff=backoff_strategy,\n            base_delay=base_delay,\n            max_delay=max_delay,\n            retryable_errors=retryable_errors,\n        )\n        retry_executor = RetryExecutor(retry_policy)\n\n        if asyncio.iscoroutinefunction(func):\n\n            @functools.wraps(func)\n            async def async_wrapper(*args, **kwargs):\n                return await retry_executor.execute_async(func, *args, **kwargs)\n\n            return async_wrapper\n        else:\n\n            @functools.wraps(func)\n            def sync_wrapper(*args, **kwargs):\n                return retry_executor.execute_sync(func, *args, **kwargs)\n\n            return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/#plating.with_timing","title":"with_timing","text":"<pre><code>with_timing(func: F) -&gt; F\n</code></pre> <p>Decorator for automatic timing with structured logging.</p> <p>Uses foundation's timed_block for consistent timing and logging.</p> Source code in <code>src/plating/decorators.py</code> <pre><code>def with_timing(func: F) -&gt; F:\n    \"\"\"Decorator for automatic timing with structured logging.\n\n    Uses foundation's timed_block for consistent timing and logging.\n    \"\"\"\n    if asyncio.iscoroutinefunction(func):\n\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            from provide.foundation.utils import timed_block\n\n            operation_name = f\"{func.__module__}.{func.__name__}\"\n            with timed_block(logger, operation_name) as timer:\n                return await func(*args, **kwargs)\n\n        return async_wrapper\n    else:\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            from provide.foundation.utils import timed_block\n\n            operation_name = f\"{func.__module__}.{func.__name__}\"\n            with timed_block(logger, operation_name) as timer:\n                return func(*args, **kwargs)\n\n        return sync_wrapper\n</code></pre>"},{"location":"api/#plating.get_plating_registry","title":"get_plating_registry","text":"<pre><code>get_plating_registry(\n    package_name: str | None = None,\n) -&gt; PlatingRegistry\n</code></pre> <p>Get or create the global plating registry.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str | None</code> <p>Package to search for components, or None to search all packages</p> <code>None</code> <p>Returns:</p> Type Description <code>PlatingRegistry</code> <p>PlatingRegistry instance</p> Source code in <code>src/plating/registry.py</code> <pre><code>def get_plating_registry(package_name: str | None = None) -&gt; PlatingRegistry:\n    \"\"\"Get or create the global plating registry.\n\n    Args:\n        package_name: Package to search for components, or None to search all packages\n\n    Returns:\n        PlatingRegistry instance\n    \"\"\"\n    global _global_registry\n    if _global_registry is None:\n        _global_registry = PlatingRegistry(package_name)\n    return _global_registry\n</code></pre>"},{"location":"api/#plating.reset_plating_registry","title":"reset_plating_registry","text":"<pre><code>reset_plating_registry() -&gt; None\n</code></pre> <p>Reset the global registry (primarily for testing).</p> Source code in <code>src/plating/registry.py</code> <pre><code>def reset_plating_registry() -&gt; None:\n    \"\"\"Reset the global registry (primarily for testing).\"\"\"\n    global _global_registry\n    _global_registry = None\n</code></pre>"},{"location":"architecture/01-overview/","title":"Architecture Overview","text":"<p>The <code>TofuSoup</code> project is a modular, CLI-driven framework designed for cross-language conformance testing and development tooling within the OpenTofu ecosystem.</p> <p>The architecture is segmented into several key domains:</p> <ol> <li> <p>Main CLI (<code>cli.py</code>): The central entry point, built with <code>click</code>. It uses a <code>LazyGroup</code> to ensure fast startup times by only loading the code for a specific subcommand when it is invoked.</p> </li> <li> <p>Core Utilities (<code>common/</code>): Provides shared services for all other components, including:</p> <ul> <li>Configuration (<code>config.py</code>): Loads and parses the <code>soup.toml</code> file.</li> <li>Exceptions (<code>exceptions.py</code>): Defines custom, project-specific exceptions.</li> <li>Rich Output (<code>rich_utils.py</code>): Helpers for creating enhanced terminal output with the <code>rich</code> library.</li> </ul> </li> <li> <p>Protocol/Component Tooling: Each core technology (<code>cty</code>, <code>hcl</code>, <code>rpc</code>, <code>wire</code>) has a dedicated module containing its CLI implementation and business logic. This modular design makes the system easy to extend.</p> </li> <li> <p>Harness Management (<code>harness/</code>): This component is responsible for the lifecycle of external test harnesses, which are primarily Go binaries. It abstracts the details of building, locating, and cleaning these executables, with behavior configurable via <code>soup.toml</code>.</p> </li> <li> <p>Conformance Testing (<code>testing/</code>, <code>conformance/</code>): This is the core of the suite. The <code>testing/</code> module provides the <code>soup test</code> CLI and logic for invoking <code>pytest</code>. The actual test suites reside in <code>conformance/</code>.</p> </li> <li> <p>Documentation (<code>docs/</code>, <code>.plating</code> system): A co-located documentation framework that treats documentation as a first-class citizen of the development process, tightly coupling it with the source code to prevent drift.</p> </li> </ol>"},{"location":"architecture/02-conformance-testing-strategy/","title":"Conformance Testing Strategy","text":"<p>This document outlines the architecture for the TofuSoup conformance testing suite.</p>"},{"location":"architecture/02-conformance-testing-strategy/#testing-philosophy-souptest-vs-pytest","title":"Testing Philosophy: <code>souptest</code> vs. <code>pytest</code>","text":"<p>A core distinction in this project is the separation of concerns in testing: -   Conformance Tests (<code>souptest_*.py</code>): These tests, located in <code>tofusoup/conformance/</code>, are for verifying cross-language compatibility. They compare the behavior of Python implementations against the canonical Go harnesses. They are run via the <code>soup test</code> command. -   Internal Tests (<code>test_*.py</code>): These are standard unit and integration tests for the <code>tofusoup</code> tool itself. They are located in <code>tofusoup/tests/</code> and are run using <code>pytest</code> directly.</p>"},{"location":"architecture/02-conformance-testing-strategy/#architectural-design","title":"Architectural Design","text":"<p>The conformance suite is organized into a hierarchical and purpose-driven structure to ensure clarity, prevent duplication, and provide a scalable foundation for comprehensive testing.</p>"},{"location":"architecture/02-conformance-testing-strategy/#design-principles","title":"Design Principles","text":"<ol> <li>Hierarchical Organization: Reflect test complexity and dependencies.</li> <li>Cross-Cutting Separation: Create dedicated areas for security, performance, and integration.</li> <li>Single Source of Truth: Eliminate duplication in test scenarios and fixtures.</li> <li>Clear Purpose: Each directory has an explicit, non-overlapping responsibility.</li> </ol>"},{"location":"architecture/02-conformance-testing-strategy/#directory-structure","title":"Directory Structure","text":"<pre><code>conformance/\n\u251c\u2500\u2500 README.md                           # Testing strategy and execution guide\n\u251c\u2500\u2500 conftest.py                         # Global fixtures and matrix configurations\n\u2502\n\u251c\u2500\u2500 unit/                               # Individual protocol conformance\n\u2502   \u251c\u2500\u2500 souptest_cty_conformance.py\n\u2502   \u251c\u2500\u2500 souptest_wire_conformance.py\n\u2502   \u2514\u2500\u2500 souptest_rpc_conformance.py\n\u2502\n\u251c\u2500\u2500 integration/                        # Cross-protocol integration testing\n\u2502   \u251c\u2500\u2500 souptest_full_stack_matrix.py      # Complete CTY\u2192Wire\u2192RPC flow\n\u2502   \u2514\u2500\u2500 souptest_provider_lifecycle.py     # Full Terraform provider scenarios\n\u2502\n\u251c\u2500\u2500 security/                           # Security-focused conformance\n\u2502   \u2514\u2500\u2500 souptest_crypto_matrix.py          # All cipher/curve combinations\n\u2502\n\u251c\u2500\u2500 scenarios/                          # End-to-end BDD-style scenario testing\n\u2502   \u251c\u2500\u2500 terraform_equivalence/\n\u2502   \u2502   \u251c\u2500\u2500 basic_operations.feature\n\u2502   \u2502   \u2514\u2500\u2500 step_definitions/\n\u2502   \u2514\u2500\u2500 souptest_scenario_runner.py\n\u2502\n\u2514\u2500\u2500 fixtures/                           # Shared test data and configuration\n    \u251c\u2500\u2500 cty_data/\n    \u2514\u2500\u2500 certificates/\n</code></pre> <p>This architecture provides a robust framework for implementing matrix-based testing and ensuring systematic validation of TofuSoup components against their canonical Go counterparts.</p>"},{"location":"architecture/03-rpc-matrix-specification/","title":"RPC K/V Matrix Testing Specification","text":"<p>This document specifies the design for a systematic, matrix-based test suite for the RPC Key/Value store example. It focuses on covering all combinations of client/server language implementations and cryptographic configurations.</p>"},{"location":"architecture/03-rpc-matrix-specification/#testing-matrix-dimensions","title":"Testing Matrix Dimensions","text":""},{"location":"architecture/03-rpc-matrix-specification/#1-language-implementation-combinations","title":"1. Language Implementation Combinations","text":"<ul> <li>Client Languages: <code>go</code>, <code>pyvider</code></li> <li>Server Languages: <code>go</code>, <code>pyvider</code></li> <li>Total Combinations: 4 client-server pairs</li> </ul>"},{"location":"architecture/03-rpc-matrix-specification/#2-authentication-crypto-matrix","title":"2. Authentication &amp; Crypto Matrix","text":"<ul> <li>Authentication Mode: <code>auto_mtls</code> (Automatic mutual TLS with certificate generation)</li> <li>RSA Key Sizes: <code>rsa_2048</code>, <code>rsa_4096</code></li> <li>Elliptic Curve Options: <code>ec_256</code> (P-256), <code>ec_384</code> (P-384), <code>ec_521</code> (P-521)</li> </ul> <p>This results in 5 unique cryptographic configurations to be tested against each of the 4 language combinations, for a total of 20 distinct test cases.</p>"},{"location":"architecture/03-rpc-matrix-specification/#implementation-specification","title":"Implementation Specification","text":"<p>The test suite will be implemented using <code>pytest</code> parameterization.</p>"},{"location":"architecture/03-rpc-matrix-specification/#1-matrix-configuration-matrix_configpy","title":"1. Matrix Configuration (<code>matrix_config.py</code>)","text":"<p>A central file will define the parameters for the matrix, generating a list of <code>pytest.param</code> objects. Each parameter set will contain the client language, server language, and a <code>CryptoConfig</code> object detailing the required mTLS setup.</p>"},{"location":"architecture/03-rpc-matrix-specification/#2-test-implementation-test_rpc_kv_matrixpy","title":"2. Test Implementation (<code>test_rpc_kv_matrix.py</code>)","text":"<p>A single, parameterized test function, <code>test_rpc_kv_operations_matrix</code>, will execute the core test logic for every combination generated by the matrix configuration. The test logic will: 1.  Create an isolated temporary directory for the test run. 2.  Start the appropriate server (Go or Python) with the specified crypto configuration. 3.  Create a client (Go or Python) configured to connect to the server. 4.  Perform <code>PUT</code>, <code>GET</code>, and <code>DELETE</code> operations, verifying the correctness of each. 5.  Test error handling, such as getting a non-existent key.</p>"},{"location":"architecture/03-rpc-matrix-specification/#3-harness-factory-harnesskv_factorypy","title":"3. Harness Factory (<code>harness/kv_factory.py</code>)","text":"<p>Factory functions (<code>create_kv_server</code>, <code>create_kv_client</code>) will abstract the creation of server and client instances. Based on the <code>language</code> parameter, these factories will return a running instance of either the Go or Python harness, configured for the specific test.</p> <p>This focused specification ensures systematic validation of RPC K/V functionality across all required language and cryptographic combinations while maintaining clean, maintainable test code.</p>"},{"location":"architecture/04-garnish-asset-bundle-system/","title":"Macro Rendering Error","text":"<p>File: <code>architecture/04-garnish-asset-bundle-system.md</code></p> <p>UndefinedError: 'schema' is undefined</p> <pre><code>Traceback (most recent call last):\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/mkdocs_macros/plugin.py\", line 699, in render\n    return md_template.render(**page_variables)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 84, in top-level template code\n  File \"/Users/tim/code/gh/provide-io/provide-foundation/.venv/lib/python3.11/site-packages/jinja2/utils.py\", line 92, in from_obj\n    if hasattr(obj, \"jinja_pass_arg\"):\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\njinja2.exceptions.UndefinedError: 'schema' is undefined\n</code></pre>"},{"location":"architecture/05-wire-protocol-details/","title":"Terraform Object Wire Protocol: Dynamic Type Encoding","text":"<p>This document details how CTY Dynamic Values (<code>cty.DynamicPseudoType</code>) are encoded and decoded in the TofuSoup project, ensuring compatibility between the Go reference harness and the Python <code>pyvider</code> libraries.</p>"},{"location":"architecture/05-wire-protocol-details/#dynamic-value-wire-format","title":"Dynamic Value Wire Format","text":"<p>When a <code>cty.DynamicVal</code> is transmitted using the Terraform Object Wire Protocol (which uses MessagePack), it is encoded as a 2-element MessagePack array:</p> <pre><code>[ &lt;type_specification_bytes&gt;, &lt;value_bytes&gt; ]\n</code></pre> <ol> <li> <p><code>&lt;type_specification_bytes&gt;</code> (First Element):</p> <ul> <li>This element represents the concrete type of the value that the dynamic value actually holds.</li> <li>Encoding Process:<ol> <li>The concrete <code>cty.Type</code> of the value is determined (e.g., <code>cty.String</code>).</li> <li>This type is marshalled into its JSON string representation (e.g., <code>\"string\"</code> or <code>[\"list\",\"number\"]</code>).</li> <li>The UTF-8 bytes of this JSON string are then encoded as a MessagePack binary data type (<code>bin</code> family).</li> </ol> </li> </ul> </li> <li> <p><code>&lt;value_bytes&gt;</code> (Second Element):</p> <ul> <li>This element is the standard MessagePack encoding of the concrete <code>cty.Value</code> itself.</li> </ul> </li> </ol>"},{"location":"architecture/05-wire-protocol-details/#example","title":"Example","text":"<p>Consider a dynamic value holding <code>cty.StringVal(\"hello\")</code>.</p> <ol> <li>Concrete Type: <code>cty.String</code></li> <li>JSON Type String: The literal string <code>\"string\"</code>.</li> <li><code>&lt;type_specification_bytes&gt;</code>: The MessagePack <code>bin</code> encoding of the UTF-8 bytes for <code>\"string\"</code>.<ul> <li>Hex: <code>c40822737472696e6722</code></li> </ul> </li> <li>Concrete Value: <code>cty.StringVal(\"hello\")</code></li> <li><code>&lt;value_bytes&gt;</code>: The MessagePack <code>str</code> encoding of \"hello\".<ul> <li>Hex: <code>a568656c6c6f</code></li> </ul> </li> <li>Final 2-Element Msgpack Array:<ul> <li>Hex: <code>92c40822737472696e6722a568656c6c6f</code></li> </ul> </li> <li>Base64 Representation: <code>ksQIInN0cmluZyKlaGVsbG8=</code></li> </ol> <p>This method ensures that the type constraint of the dynamic value is clearly and unambiguously encoded in the wire format, allowing the decoding side to correctly interpret the subsequent value bytes.</p>"},{"location":"architecture/06-polyglot-cli-strategy/","title":"Polyglot CLI Strategy","text":"<p>This document outlines the architectural strategy for creating a family of TofuSoup command-line interfaces across multiple languages, ensuring a consistent developer experience and robust, symmetric testing capabilities.</p>"},{"location":"architecture/06-polyglot-cli-strategy/#1-core-principle-feature-parity","title":"1. Core Principle: Feature Parity","text":"<p>The primary goal is to achieve feature parity between the main Python-based <code>soup</code> CLI and its counterparts in other languages, starting with Go (<code>soup-go</code>). This means that where applicable, a developer should be able to use the same commands, subcommands, and flags in <code>soup-go</code> as they would in <code>soup</code>.</p> <p>This creates a predictable and powerful ecosystem where developers can use the tools in their preferred language, and the testing suite can validate Python components against Go components using an identical set of commands.</p>"},{"location":"architecture/06-polyglot-cli-strategy/#2-go-implementation-soup-go","title":"2. Go Implementation: <code>soup-go</code>","text":"<p>The Go implementation of the TofuSoup CLI will be named <code>soup-go</code> and will be built using the Cobra library to provide a robust and familiar CLI structure. The existing Go harnesses (<code>go-cty</code>, <code>go-hcl</code>, etc.) will be refactored and integrated into this single, unified <code>soup-go</code> binary.</p>"},{"location":"architecture/06-polyglot-cli-strategy/#target-soup-go-structure","title":"Target <code>soup-go</code> Structure","text":"<p>The <code>soup-go</code> CLI will mirror the structure of the Python <code>soup</code> CLI.</p> <p>Hypothetical <code>soup-go --help</code> Output: <pre><code>A Go implementation of the TofuSoup conformance and utility toolkit.\n\nUsage:\n  soup-go [command]\n\nAvailable Commands:\n  cty         Utilities for CTY data (view, convert, validate)\n  hcl         Utilities for HCL file processing (view, convert)\n  rpc         Utilities for testing RPC components (kv get, kv put)\n  wire        Tools for encoding/decoding Terraform Wire Protocol objects\n  help        Help about any command\n\nFlags:\n  -h, --help          help for soup-go\n      --log-level string   Set the logging level (default \"info\")\n</code></pre></p>"},{"location":"architecture/06-polyglot-cli-strategy/#3-role-in-conformance-testing","title":"3. Role in Conformance Testing","text":"<p>This strategy transforms the Go harnesses from simple, single-purpose test executables into a full-featured, language-specific implementation of the TofuSoup toolkit. This enables a powerful, symmetric testing model:</p> <ul> <li>Python vs. Go: The <code>soup test</code> command can invoke <code>soup-go</code> to get canonical outputs for comparison.</li> <li>Go vs. Python: A future Go-based test runner could invoke the Python <code>soup</code> CLI to validate Go components.</li> </ul> <p>This ensures that the entire toolchain, not just the underlying libraries, is conformant across languages.</p>"},{"location":"architecture/07-stock-service-design/","title":"Stock Service Design Document","text":""},{"location":"architecture/07-stock-service-design/#overview","title":"Overview","text":"<p>The Stock service is a multi-language gRPC service designed to test cross-language compatibility without the complexity of plugin handshakes. It extends the simple key-value pattern from kvproto with additional gRPC patterns (streaming, bidirectional) to provide comprehensive testing coverage.</p>"},{"location":"architecture/07-stock-service-design/#motivation","title":"Motivation","text":""},{"location":"architecture/07-stock-service-design/#current-state","title":"Current State","text":"<ul> <li>TofuSoup's RPC tests focus on plugin protocol compatibility (go-plugin framework)</li> <li>The existing kvproto project tests direct gRPC but lives outside TofuSoup</li> <li>Plugin protocol adds complexity when testing basic gRPC interoperability</li> </ul>"},{"location":"architecture/07-stock-service-design/#goals","title":"Goals","text":"<ol> <li>Test pure gRPC compatibility across 10+ languages</li> <li>Provide a standard service that exercises all gRPC communication patterns</li> <li>Integrate kvproto's multi-language implementations into TofuSoup</li> <li>Enable testing of pyvider servers in <code>--force</code> mode with non-plugin clients</li> </ol>"},{"location":"architecture/07-stock-service-design/#architecture","title":"Architecture","text":""},{"location":"architecture/07-stock-service-design/#service-name-stock","title":"Service Name: Stock","text":"<p>The name \"Stock\" works on multiple levels: - Soup stock: The base/foundation of soup (fitting TofuSoup theme) - Inventory stock: Storage metaphor for key-value operations - Stock market: Streaming updates and trading metaphor for bidirectional streams</p>"},{"location":"architecture/07-stock-service-design/#directory-structure","title":"Directory Structure","text":"<pre><code>tofusoup/\n\u251c\u2500\u2500 conformance/\n\u2502   \u2514\u2500\u2500 stock/              # Stock service conformance tests\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 conftest.py\n\u2502       \u251c\u2500\u2500 matrix_config.py\n\u2502       \u2514\u2500\u2500 souptest_stock_matrix.py\n\u251c\u2500\u2500 stock/                  # All Stock implementations\n\u2502   \u251c\u2500\u2500 proto/\n\u2502   \u2502   \u2514\u2500\u2500 stock.proto     # Single source of truth\n\u2502   \u251c\u2500\u2500 go/\n\u2502   \u2502   \u251c\u2500\u2500 cmd/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 client/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 server/\n\u2502   \u2502   \u251c\u2500\u2500 go.mod\n\u2502   \u2502   \u2514\u2500\u2500 Makefile\n\u2502   \u251c\u2500\u2500 python/\n\u2502   \u2502   \u251c\u2500\u2500 stock_client.py\n\u2502   \u2502   \u251c\u2500\u2500 stock_server.py\n\u2502   \u2502   \u2514\u2500\u2500 requirements.txt\n\u2502   \u251c\u2500\u2500 java/\n\u2502   \u2502   \u251c\u2500\u2500 pom.xml\n\u2502   \u2502   \u2514\u2500\u2500 src/main/java/\n\u2502   \u251c\u2500\u2500 ruby/\n\u2502   \u251c\u2500\u2500 rust/\n\u2502   \u251c\u2500\u2500 csharp/\n\u2502   \u2514\u2500\u2500 ... (other languages)\n\u2514\u2500\u2500 src/tofusoup/\n    \u2514\u2500\u2500 stock/              # Stock CLI integration\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 cli.py          # CLI commands\n        \u2514\u2500\u2500 harness.py      # Build/management logic\n</code></pre>"},{"location":"architecture/07-stock-service-design/#proto-definition","title":"Proto Definition","text":"<pre><code>service Stock {\n    // Basic KV operations (unary) - backwards compatible\n    rpc Get(GetRequest) returns (GetResponse);\n    rpc Put(PutRequest) returns (Empty);\n\n    // Server streaming - monitor changes\n    rpc Monitor(WatchRequest) returns (stream WatchEvent);\n\n    // Client streaming - batch operations\n    rpc Batch(stream BatchItem) returns (BatchSummary);\n\n    // Bidirectional - trading simulation\n    rpc Trade(stream TradeOrder) returns (stream TradeFill);\n\n    // Status/health check\n    rpc Inventory(Empty) returns (InventoryStatus);\n}\n</code></pre>"},{"location":"architecture/07-stock-service-design/#cli-design","title":"CLI Design","text":""},{"location":"architecture/07-stock-service-design/#language-first-commands","title":"Language-First Commands","text":"<pre><code># Start servers\nsoup stock go server --port 50051\nsoup stock python server --tls-mode auto\nsoup stock java server --cert-file server.crt\n\n# Run clients\nsoup stock ruby client get mykey --server localhost:50051\nsoup stock rust client put mykey \"value\" --server localhost:50051\nsoup stock go client monitor \"prefix/*\" --server localhost:50051\n\n# Convenience shortcuts (defaults to Python)\nsoup stock get mykey\nsoup stock put mykey \"value\"\nsoup stock inventory\n</code></pre>"},{"location":"architecture/07-stock-service-design/#why-not-under-soup-rpc","title":"Why Not Under <code>soup rpc</code>?","text":"<ol> <li>Clear Separation: </li> <li><code>soup rpc</code> = Plugin protocol (handshake, broker, stdio)</li> <li> <p><code>soup stock</code> = Direct gRPC (no handshake)</p> </li> <li> <p>Different Use Cases:</p> </li> <li><code>soup rpc</code> tests Terraform provider compatibility</li> <li> <p><code>soup stock</code> tests language interoperability</p> </li> <li> <p>Simpler Mental Model:</p> </li> <li>Stock is a standalone service, not a variant of RPC</li> </ol>"},{"location":"architecture/07-stock-service-design/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"architecture/07-stock-service-design/#phase-1-core-languages-week-1","title":"Phase 1: Core Languages (Week 1)","text":"<ul> <li>[ ] Python implementation (base reference)</li> <li>[ ] Go implementation (performance baseline)</li> <li>[ ] Proto compilation setup for all languages</li> </ul>"},{"location":"architecture/07-stock-service-design/#phase-2-migrate-kvproto-week-2","title":"Phase 2: Migrate kvproto (Week 2)","text":"<ul> <li>[ ] Move existing kvproto implementations</li> <li>[ ] Update to use Stock proto definition</li> <li>[ ] Standardize CLI interface across languages</li> </ul>"},{"location":"architecture/07-stock-service-design/#phase-3-testing-infrastructure-week-3","title":"Phase 3: Testing Infrastructure (Week 3)","text":"<ul> <li>[ ] Matrix test configuration</li> <li>[ ] Performance benchmarks</li> <li>[ ] TLS/mTLS test scenarios</li> </ul>"},{"location":"architecture/07-stock-service-design/#phase-4-additional-languages-week-4","title":"Phase 4: Additional Languages (Week 4+)","text":"<ul> <li>[ ] Java, Ruby, C#, Rust implementations</li> <li>[ ] JavaScript/Node.js, C++, PHP</li> <li>[ ] Kotlin, Scala, Swift (stretch goals)</li> </ul>"},{"location":"architecture/07-stock-service-design/#testing-matrix","title":"Testing Matrix","text":""},{"location":"architecture/07-stock-service-design/#dimensions","title":"Dimensions","text":"<ol> <li>Client Language: 10+ implementations</li> <li>Server Language: 10+ implementations  </li> <li>TLS Configuration: none, server-only, mTLS</li> <li>Operations: get/put, streaming, batch, bidirectional</li> </ol>"},{"location":"architecture/07-stock-service-design/#example-test-cases","title":"Example Test Cases","text":"<ul> <li>Python client \u2192 Go server (mTLS, streaming)</li> <li>Java client \u2192 Ruby server (no TLS, batch operations)</li> <li>Rust client \u2192 Python server (server TLS, bidirectional)</li> </ul> <p>Total potential combinations: 10 \u00d7 10 \u00d7 3 \u00d7 4 = 1,200 tests</p>"},{"location":"architecture/07-stock-service-design/#optimized-test-subsets","title":"Optimized Test Subsets","text":"<ul> <li>Quick: 3 clients \u00d7 3 servers \u00d7 1 TLS \u00d7 2 ops = 18 tests</li> <li>Standard: 5 clients \u00d7 5 servers \u00d7 2 TLS \u00d7 3 ops = 150 tests</li> <li>Full: All combinations (weekend run)</li> </ul>"},{"location":"architecture/07-stock-service-design/#integration-with-existing-systems","title":"Integration with Existing Systems","text":""},{"location":"architecture/07-stock-service-design/#works-with-pyvider-force-mode","title":"Works With pyvider --force Mode","text":"<pre><code># Start pyvider server without handshake\npython my_provider.py provide --force --port 50051\n\n# Connect with any Stock client\nsoup stock java client get tf_resource_123\nsoup stock go client monitor \"tf_state/*\"\n</code></pre>"},{"location":"architecture/07-stock-service-design/#comparison-with-plugin-rpc","title":"Comparison with Plugin RPC","text":"Feature Plugin RPC (<code>soup rpc</code>) Stock (<code>soup stock</code>) Handshake Required None Port Negotiation Dynamic Fixed Stdio Forwarding Yes No Language Support Go + Python 10+ languages Use Case Terraform providers General gRPC testing"},{"location":"architecture/07-stock-service-design/#success-metrics","title":"Success Metrics","text":"<ol> <li>Coverage: All 10+ languages have working implementations</li> <li>Compatibility: 95%+ of cross-language tests pass</li> <li>Performance: Benchmark data for each language pair</li> <li>Adoption: Stock becomes the standard for gRPC testing in TofuSoup</li> </ol>"},{"location":"architecture/07-stock-service-design/#future-extensions","title":"Future Extensions","text":"<ol> <li>Additional Patterns:</li> <li>Request deadlines/timeouts</li> <li>Metadata/header propagation</li> <li>Compression testing</li> <li> <p>Load balancing scenarios</p> </li> <li> <p>Observability:</p> </li> <li>OpenTelemetry integration</li> <li>Prometheus metrics</li> <li> <p>Distributed tracing</p> </li> <li> <p>Chaos Testing:</p> </li> <li>Network delays</li> <li>Partial failures</li> <li>Message corruption</li> </ol>"},{"location":"architecture/07-stock-service-design/#conclusion","title":"Conclusion","text":"<p>The Stock service provides a clean, focused way to test gRPC compatibility across languages without the complexity of plugin protocols. By integrating kvproto's work and extending it with additional RPC patterns, TofuSoup gains comprehensive cross-language testing capabilities that complement its existing plugin-focused tests.</p>"},{"location":"future/bundle-discovery-pattern/","title":"Bundle Discovery Pattern for Foundation","text":""},{"location":"future/bundle-discovery-pattern/#overview","title":"Overview","text":"<p>The <code>PlatingBundle</code> and <code>PlatingDiscovery</code> patterns from plating are generic and reusable for any packaged asset discovery. This could become a foundation module.</p>"},{"location":"future/bundle-discovery-pattern/#proposed-foundation-module-providefoundationdiscovery","title":"Proposed Foundation Module: <code>provide.foundation.discovery</code>","text":""},{"location":"future/bundle-discovery-pattern/#core-classes","title":"Core Classes","text":"<pre><code>@dataclass\nclass ResourceBundle:\n    \"\"\"Generic resource bundle for any packaged assets.\"\"\"\n    name: str\n    bundle_dir: Path\n    resource_type: str\n    metadata: dict[str, Any] = field(default_factory=dict)\n\n    @property\n    def assets_dir(self) -&gt; Path:\n        \"\"\"Directory containing assets.\"\"\"\n        return self.bundle_dir / \"assets\"\n\n    @property  \n    def config_dir(self) -&gt; Path:\n        \"\"\"Directory containing configuration.\"\"\"\n        return self.bundle_dir / \"config\"\n\n    def load_assets(self) -&gt; dict[str, str]:\n        \"\"\"Load all asset files as string content.\"\"\"\n        # Implementation similar to PlatingBundle.load_examples\n\n    def load_metadata(self) -&gt; dict[str, Any]:\n        \"\"\"Load bundle metadata from config files.\"\"\"\n        # Implementation for loading YAML/JSON metadata\n\nclass ResourceDiscovery:\n    \"\"\"Discover resource bundles from installed packages.\"\"\"\n\n    def __init__(self, package_pattern: str = \"*.resources\"):\n        self.package_pattern = package_pattern\n\n    def discover_bundles(self, resource_type: str | None = None) -&gt; list[ResourceBundle]:\n        \"\"\"Discover all resource bundles from packages.\"\"\"\n        # Generic implementation for any package discovery\n\n    def scan_directory(self, directory: Path) -&gt; list[ResourceBundle]:\n        \"\"\"Scan a directory for resource bundles.\"\"\"\n        # Local directory scanning\n</code></pre>"},{"location":"future/bundle-discovery-pattern/#usage-examples","title":"Usage Examples","text":"<pre><code># For documentation generation (current plating use case)\nfrom provide.foundation.discovery import ResourceDiscovery, ResourceBundle\n\ndiscovery = ResourceDiscovery(\"*.components\")  \ndoc_bundles = discovery.discover_bundles(resource_type=\"documentation\")\n\n# For plugin discovery\nplugin_discovery = ResourceDiscovery(\"*.plugins\")\nplugins = plugin_discovery.discover_bundles(resource_type=\"extension\")\n\n# For template discovery  \ntemplate_discovery = ResourceDiscovery(\"*.templates\")\ntemplates = template_discovery.discover_bundles(resource_type=\"jinja2\")\n</code></pre>"},{"location":"future/bundle-discovery-pattern/#benefits","title":"Benefits","text":"<ol> <li>Reusability: Any project needing asset/resource discovery</li> <li>Standardization: Common pattern across provide ecosystem</li> <li>Extensibility: Support for different bundle types and metadata formats</li> <li>Performance: Caching and optimization opportunities</li> </ol>"},{"location":"future/bundle-discovery-pattern/#migration-path","title":"Migration Path","text":"<ol> <li>Extract plating's bundle logic to foundation</li> <li>Update plating to use foundation's discovery module  </li> <li>Provide backward compatibility adapters</li> <li>Document migration guide for other projects</li> </ol>"},{"location":"future/bundle-discovery-pattern/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Support multiple asset directories per bundle</li> <li>Flexible metadata loading (YAML, JSON, TOML)</li> <li>Plugin hooks for custom bundle types</li> <li>Caching layer for performance</li> <li>Async discovery support for large package sets</li> </ul>"},{"location":"future/template-processing-pipeline/","title":"Template Processing Pipeline for Foundation","text":""},{"location":"future/template-processing-pipeline/#overview","title":"Overview","text":"<p>Plating's async template rendering with Jinja2 integration and partials support could become a general-purpose template processing module in foundation.</p>"},{"location":"future/template-processing-pipeline/#proposed-foundation-module-providefoundationtemplates","title":"Proposed Foundation Module: <code>provide.foundation.templates</code>","text":""},{"location":"future/template-processing-pipeline/#core-classes","title":"Core Classes","text":"<pre><code>from typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass TemplateLoader(Protocol):\n    \"\"\"Protocol for template loading strategies.\"\"\"\n\n    async def load_template(self, name: str) -&gt; str:\n        \"\"\"Load template content by name.\"\"\"\n        ...\n\n    async def load_partials(self, template_name: str) -&gt; dict[str, str]:\n        \"\"\"Load partial templates related to a template.\"\"\"\n        ...\n\nclass AsyncTemplateEngine:\n    \"\"\"Async template processing with partials support.\"\"\"\n\n    def __init__(\n        self,\n        loader: TemplateLoader,\n        engine_type: str = \"jinja2\",\n        global_context: dict[str, Any] = None\n    ):\n        self.loader = loader\n        self.engine_type = engine_type\n        self.global_context = global_context or {}\n        self._setup_engine()\n\n    async def render(\n        self, \n        template_name: str, \n        context: dict[str, Any],\n        partials: dict[str, str] = None\n    ) -&gt; str:\n        \"\"\"Render template with context and partials.\"\"\"\n        # Async implementation with metrics tracking\n\n    async def render_batch(\n        self, \n        templates: list[tuple[str, dict[str, Any]]]\n    ) -&gt; list[str]:\n        \"\"\"Render multiple templates in parallel.\"\"\"\n        # Parallel processing with rate limiting\n\n    def add_global_function(self, name: str, func: callable):\n        \"\"\"Add global template function.\"\"\"\n        # Similar to plating's template function registration\n\nclass FileTemplateLoader:\n    \"\"\"Load templates from filesystem.\"\"\"\n\n    def __init__(self, template_dirs: list[Path]):\n        self.template_dirs = template_dirs\n\n    async def load_template(self, name: str) -&gt; str:\n        # Find and load template file\n\n    async def load_partials(self, template_name: str) -&gt; dict[str, str]:\n        # Load related partial templates\n\nclass BundleTemplateLoader:\n    \"\"\"Load templates from resource bundles.\"\"\"\n\n    def __init__(self, bundles: list[ResourceBundle]):\n        self.bundles = bundles\n\n    async def load_template(self, name: str) -&gt; str:\n        # Load template from appropriate bundle\n\nclass CachingTemplateLoader:\n    \"\"\"Wrapper that adds caching to any loader.\"\"\"\n\n    def __init__(self, loader: TemplateLoader, cache_ttl: int = 300):\n        self.loader = loader\n        self.cache_ttl = cache_ttl\n        self._cache = {}\n</code></pre>"},{"location":"future/template-processing-pipeline/#usage-examples","title":"Usage Examples","text":"<pre><code># Basic usage\nfrom provide.foundation.templates import AsyncTemplateEngine, FileTemplateLoader\n\nloader = FileTemplateLoader([Path(\"templates\"), Path(\"partials\")])\nengine = AsyncTemplateEngine(loader)\n\n# Add custom functions\nengine.add_global_function(\"format_date\", lambda d: d.strftime(\"%Y-%m-%d\"))\n\n# Render single template\nresult = await engine.render(\"documentation.md\", {\n    \"title\": \"API Docs\",\n    \"components\": components_data\n})\n\n# Render multiple templates in parallel\nresults = await engine.render_batch([\n    (\"api.md\", api_context),\n    (\"guide.md\", guide_context),\n    (\"reference.md\", ref_context)\n])\n\n# Using with resource bundles  \nfrom provide.foundation.discovery import ResourceDiscovery\n\ndiscovery = ResourceDiscovery(\"*.templates\")\nbundles = discovery.discover_bundles(resource_type=\"documentation\")\n\nbundle_loader = BundleTemplateLoader(bundles)\ncached_loader = CachingTemplateLoader(bundle_loader, cache_ttl=600)\nengine = AsyncTemplateEngine(cached_loader)\n</code></pre>"},{"location":"future/template-processing-pipeline/#features","title":"Features","text":"<ol> <li>Async-First: Built for high-performance parallel rendering</li> <li>Pluggable Loaders: Multiple template source strategies</li> <li>Caching Layer: Template compilation and content caching</li> <li>Metrics Integration: Built-in performance monitoring</li> <li>Multiple Engines: Support for Jinja2, Mako, etc.</li> <li>Partial Support: Modular template composition</li> <li>Global Functions: Extensible template function registry</li> <li>Rate Limiting: Controlled resource usage in batch operations</li> </ol>"},{"location":"future/template-processing-pipeline/#advanced-features","title":"Advanced Features","text":"<pre><code># With resilience patterns\nfrom provide.foundation.resilience import RetryExecutor, CircuitBreaker\n\nengine = AsyncTemplateEngine(\n    loader=loader,\n    retry_executor=RetryExecutor(...),\n    circuit_breaker=CircuitBreaker(...)\n)\n\n# With streaming for large templates\nasync for chunk in engine.render_stream(\"large_template.html\", context):\n    # Process template chunks as they're rendered\n\n# With template inheritance and includes\nengine.add_template_path(\"base_templates/\")\nresult = await engine.render(\"child_template.html\", context)\n</code></pre>"},{"location":"future/template-processing-pipeline/#benefits","title":"Benefits","text":"<ol> <li>Performance: Async processing enables high throughput</li> <li>Flexibility: Multiple loader strategies for different use cases  </li> <li>Reliability: Built-in resilience and caching</li> <li>Observability: Metrics and monitoring integration</li> <li>Reusability: Generic enough for many template use cases</li> </ol>"},{"location":"future/template-processing-pipeline/#migration-path","title":"Migration Path","text":"<ol> <li>Extract plating's template logic to foundation</li> <li>Add async capabilities and loader abstractions</li> <li>Update plating to use foundation's template engine</li> <li>Provide compatibility layer for existing template code</li> <li>Add support for additional template engines</li> </ol>"}]}